<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="24">
<Class name="TCLEx.Function.Episode2">
<Super>%RegisteredObject</Super>
<TimeCreated>63362,50838.385866</TimeCreated>

<Method name="GetPayer">
<Description>
Получить код плательщика на уровне эпизода
на уровне наборов тестов - в вызывающей проге надо смотреть в случае, когда дата авторизации меньше даты начала использования Биралаба
Пока предполагаю, что после ввода Бирлаба код плательщика на уровне набора тестов не брали во внимание (надо спросить у Лены)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,&pPayer:%String,&pFlagGetPayerFromTestSet:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	set pPayer=""
	set pFlagGetPayerFromTestSet=1 // предполагаем, что в вызывающей проге надо смотреть код плательщика на уровне наборов тестов, если дата авторизации меньше даты начала использования Биралаба
	
	try {
		
        // Если уже есть данные TCLEx.Data.EPVisitNumberExt и нет взведенного флага на пересчет этих данных, то берем из TCLEx.Data.EPVisitNumberExtif
        if '$data(^SpeedI.DeltaPext(pEpisode))&&($get(^TEPIext(pEpisode))'="") {
	        set pPayer=$listget($get(^TEPIext(pEpisode)),2)
        }
        if pPayer'="" {
	        set pFlagGetPayerFromTestSet=0 
	        quit
        }
        
        $$$ThrowOnError(..GetPayer0(pEpisode, .pPayer, .pFlagGetPayerFromTestSet))
        

	} catch(e) { set ok=e.AsStatus() }
	quit ok
]]></Implementation>
</Method>

<Method name="GetPayer0">
<Description>
Получить код плательщика на уровне эпизода
на уровне наборов тестов - в вызывающей проге надо смотреть в случае, когда дата авторизации меньше даты начала использования Биралаба
Пока предполагаю, что после ввода Бирлаба код плательщика на уровне набора тестов не брали во внимание (надо спросить у Лены)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,&pPayer:%String,&pFlagGetPayerFromTestSet:%Boolean]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	set pPayer=""
	set pFlagGetPayerFromTestSet=1 // предполагаем, что в вызывающей проге надо смотреть код плательщика на уровне наборов тестов, если дата авторизации меньше даты начала использования Биралаба
	
	try {
	    
        // Если эпизод уже заимпорчен в Бирлаб, то берем код плательщика из BiRLab.Data.Episode
        // Есть эпизоды после ввода Бирлаб, в которых код плательщика из трека и из Бирлаба различаются
        set epis=" "_pEpisode
        if $data(^BiRLab.Data.EpisodeI("EpisodeIndex",epis)) {
	        set id=$order(^BiRLab.Data.EpisodeI("EpisodeIndex",epis,""))
	        if id'="" {
		        set pPayer=$listget($get(^BiRLab.Data.EpisodeD(id)),8)
	        }
        }
        if pPayer'="" {
	        set pFlagGetPayerFromTestSet=0 // если эпизод уже заимпорчен в Бирлаб, то смотреть код плательщика на уровне наборов тестов не надо
	        quit
        }
        
        // иначе берем в треке на уровне эпизода
        set rec=$get(^TEPI(pEpisode))
		set payepis=$piece(rec,"\",7)  //EPVIS_PaymentCode_DR  код плательщика из трека на уровне эпизода 
        if payepis'="" {
	        set pPayer=payepis
	        quit
        }
        
        // иначе берем в Бирлабе по привязке PayerHospital
        set hospitalcode=$piece(rec,"\",20)
        set pPayer=##class(BiRLab.CT.PayerHospital).GetPayerByHospital(hospitalcode)
        

	} catch(e) { set ok=e.AsStatus() }
	quit ok
]]></Implementation>
</Method>

<Method name="GetPrice">
<Description>
Вобщем то в некотром роде контексная функция (^||invForGetPrice) для отчетов с ценой
://штм</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,pTestSet:%String,pTestSetCounter:%String,pSuperSet:%String="",pDateAuthorization:%String,pDateEntry:%String,&pCito:%String,pDateStartBirLab:%String="",pPayer:%String="",pHospital:%String,pPaymentCategory:%String="",pPriceListVersion:%String="",&pPrice:%String]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=1,pPrice=""
	try {
		// если нет взведенной глобали для пересчета цены и плательщика, то берем готовую
        set isfind=0
        try {
	        if '$data(^SpeedI.DeltaPext(pEpisode))&&($get(^TEPIext(pEpisode,1,pTestSet,pTestSetCounter))'="") {
	           if pSuperSet'="" {
		           set isfind=0
		           set ts1=$order(^TEPIextI("SuperSet",pEpisode,pSuperSet,1,""))
		           if ts1'="" {
			           set tscnt1=$order(^TEPIextI("SuperSet",pEpisode,pSuperSet,1,ts1,""))
			           if tscnt1'="" {
				          set pPrice=+$listget(^TEPIext(pEpisode,1,ts1,tscnt1),1)
				          set isfind=1
			          }
		           }
	           } else {
		           set pPrice=+$listget(^TEPIext(pEpisode,1,pTestSet,pTestSetCounter),1)
		           set isfind=1
	           }
            }
        } catch(e) { set isfind=0} 
        
        
        if isfind=0 {
	            set billingitem=$select(pSuperSet'="":pSuperSet,1:pTestSet)
	            // расчет цены по старому биллингу
                if (pDateStartBirLab="")||(pDateAuthorization<pDateStartBirLab) {
	                if '$data(^||invForGetPrice) {  // создается один раз если уж вдруг какие-то старые цены оказались не посчитаны
		                do CreateIndex^PRTCLNRUS05birlab($name(^||invForGetPrice)) ;инверсии к CT_Schedule_PaymentCode
	                }
	                Set returnValue=$$GetBillingItemAmount^PRTCLNRUS05birlab(pPayer,pEpisode,pDateAuthorization,billingitem,pCito,$name(^||invForGetPrice))
                }
                // расчет цены по новому биллингу 
                else {
	                 $$$ThrowOnError(##class(BiRLab.Function.InvoiceNew).GetPriceEpisodeItem(pEpisode,billingitem,pTestSet,pTestSetCounter,pDateEntry,.pCito,pPayer,pHospital,pPaymentCategory,pPriceListVersion,.pPrice))
                }
        }
	} catch(e) { 
	     set pPrice=""
	     set ok=e.AsStatus()
	     do ##class(TCLEx.Function.General).WriteError($ze,$CLASSNAME()_":GetPrice episode="_$get(pEpisode)_", testset="_$get(pTestSet)_",tscnt="_$get(pTestSetCounter))
	}
	quit ok
]]></Implementation>
</Method>
</Class>
</Export>
