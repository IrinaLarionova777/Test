<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="24">
<Class name="TCLEx.Function.TestSet">
<Super>%RegisteredObject</Super>
<TimeCreated>62031,42176.626572</TimeCreated>

<Method name="IsPrintable">
<Description>
***
Является ли передаваемый объект набора тестов печатаемым
Параметры:
pTestSetObj - объект набора тестов
Возвращаемое значение:
1 - Печатаемый
0 - Непечатаемый</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetObj:User.EPVisitTestSet</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	// Если существует класс TCLEx.Function.TestSet(расширение для клиента) и в нем существует метод IsPrintable, то вызывается клиентский метод 
	set clientext=$Piece($Get(^CF("SM",1)),"^",28)
	if (clientext'="") {
		set classmethod=$CLASSNAME()_clientext_"||IsPrintable"
	    if ##class(%Dictionary.CompiledMethod).%ExistsId(classmethod) {
		    quit $ClassMethod($piece(classmethod,"||",1),$piece(classmethod,"||",2), $get(pTestSetObj))
	    }
	}

	If '$IsObject(pTestSetObj) Quit 0
	set testsetid=pTestSetObj.%Id()
	quit $$printable^LVBCTTS($piece(testsetid,"||",2),testsetid,"Y") 
	/*
	If ..IsAuthorised(pTestSetObj) Quit 1
	If ..IsCanceled(pTestSetObj) Quit 1
	Quit ..IsInPrintableVerificationQueue(pTestSetObj.%Id())
	*/
]]></Implementation>
</Method>

<Method name="IsAuthorised">
<Description>
Является ли набор тестов pTestSetObj авторизованным</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetObj:User.EPVisitTestSet</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If '$IsObject(pTestSetObj) Quit 0
	If (pTestSetObj.VISTSDateOfAuthorisation="")||(pTestSetObj.VISTSTimeOfAuthorisation="")||(pTestSetObj.VISTSUserAuthorisedDR="") Quit 0
	If pTestSetObj.VISTSStatusResult="A" Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsAuthorised2">
<Description>
Является ли набор тестов авторизованным</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String,pTestSet:%String,pTestSetCounter:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set rec=$get(^TEPI(pEpisode,1,pTestSet,pTestSetCounter))
	if rec="" quit 0
	
	If ($piece(rec,"\",4)="")||($piece(rec,"\",5)="")||($piece(rec,"\",6)="") Quit 0
	If $piece(rec,"\",31)="A" Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsCanceled">
<Description>
Отменен ли Набор тестов User.EPVisitTestSet с печатаемой причиной отмены  (reasonobj.CTRReportable="Y")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetObj:User.EPVisitTestSet</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If '$IsObject(pTestSetObj) Quit 0
	If (pTestSetObj.VISTSDateOfReason="")||(pTestSetObj.VISTSTimeOfReason="") Quit 0
	Set reasonobj=pTestSetObj.VISTSReasonDR
	If '$IsObject(reasonobj) Quit 0
	If reasonobj.CTRReportable="Y" Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsCanceled2">
<Description>
Отменен ли Набор тестов User.EPVisitTestSet с любой причиной отмены</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetObj:User.EPVisitTestSet</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If '$IsObject(pTestSetObj) Quit 0
	If (pTestSetObj.VISTSDateOfReason="")||(pTestSetObj.VISTSTimeOfReason="") Quit 0
	If $IsObject(pTestSetObj.VISTSReasonDR) Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsCanceled3">
<Description>
Отменен ли Набор тестов с любой причиной отмены</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String,pTestSet:%String,pTestSetCounter:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set rec=$get(^TEPI(pEpisode,1,pTestSet,pTestSetCounter))
	if rec="" quit 0
	If ($piece(rec,"\",54)="")||($piece(rec,"\",55)="") Quit 0
	set reason=$piece(rec,"\",52)
	if (reason'="")&&($data(^TTAB("CTR",reason))) quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsInPrintableVerificationQueue">
<Description>
Находиться ли набор тестов в печатаемой очереди проверки
Параметры:
pTestSetId - ID набора тестов
Возвращаемое значение:
1 - Есть в очереди
0 - Нет в очереди</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set queueid=..GetPrintableVerificationQueue(pTestSetId)
	Quit (queueid'="")
]]></Implementation>
</Method>

<Method name="GetPrintableVerificationQueue">
<Description>
ID печатаемой очереди проверки для набора тестов
Параметры:
pTestSetId - ID набора тестов
Возвращаемое значение:
ID печатаемой очереди проверки</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	If pTestSetId="" Quit ""
	Set result=""
	&sql(DECLARE QueueCursor CURSOR FOR
		Select VISTQ_Queue_DR,VISTQ_Queue_DR->CTVQ_Printable
		Into :queueid,:printable
		From SQLUser.EP_VisitTestSetQueue Where 
		(VISTQ_ParRef=:pTestSetId) and (VISTQ_Out_Date Is Null) and 	(VISTQ_Out_Time Is Null)
	)

	&sql(OPEN QueueCursor)
	&sql(FETCH QueueCursor)

	While (SQLCODE = 0) {
		If printable="Y" {
			Set result=queueid
			Quit
		}	
		&sql(FETCH QueueCursor)
	}
	&sql(CLOSE QueueCursor)
	Quit result
]]></Implementation>
</Method>

<Method name="IsCompleted">
<Description>
Является ли набор тестов pTestSetObj выполненным, т.е. авторизованнм или отмененным (с любой причиной отмены)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetObj:User.EPVisitTestSet</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	if ..IsAuthorised(pTestSetObj) Quit 1
	Quit ..IsCanceled2(pTestSetObj)
]]></Implementation>
</Method>

<Method name="IsViewable">
<Description>
***
Является ли передаваемый объект набора тестов viewable
Параметры:
pVTSRowID - %ROWID epis_"||"_ts_"||"_tscnt
Возвращаемое значение:
1 - viewable
0 - not viewable</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pVTSRowID:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set returnValue=1
	/*
	If '$IsObject(pTestSetObj) Quit 0
	set returnValue=1
	set flagConfidential=$$conf^LVBVISTS(pTestSetObj.%Id())
	if (flagConfidential="Y")||(flagConfidential="D") {  // tsobj.VISTSConfidential = "Both" or "Display"
	   set user=$$user^MVBSSUSR()
	   if user'="" {
		   set supervisor=$$seldata^MVBSSUSR(user,8)  // property SSUSR_Supervisor
		   set securitytype=$$seldata^MVBSSUSR(user,10)  // property SSUSR_PracticeSecurityType
		   if (supervisor'="Y")&&(securitytype=3) {
		      set returnValue=0
		   }
	   }
	}*/
	set user=$$user^MVBSSUSR()
	if $$ValUser^LVBVISTS(user,pVTSRowID,"V") {
		set returnValue=0
	}
	quit returnValue
]]></Implementation>
</Method>

<Method name="Departments">
<Description>
Разбиение списка наборов тестов pTestSets эпизода pEpis по отделам в которые входят эти наборы тестов
Необходимо для того, что каждый отдел печатается с новой страницы
Параметры:
pEpis - ID эпизода
pTestSets - передаваемый по ссылке список ID наборов тестов в эпизоде 
(если данные есть, то в результат попадают только эти наборы. Если не заполнено, то все печатаемые авторизованные или отмененные наборы этого эпизода)
pGlb - ссылка на глобал с возвращаемыми результатами (если не заполнено, то передается в ^||deptestsets)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpis:%String,&pTestSets:%String,pGlb:%String,pFlagPreview:%String=""]]></FormalSpec>
<Implementation><![CDATA[
	// Если существует класс TCLEx.Funclion.TestSet(расширение для клиента) и в нем существует метод Departments, то вызывается клиентский метод 
	set clientext=$Piece($Get(^CF("SM",1)),"^",28)
	if (clientext'="") {
		set classmethod=$CLASSNAME()_clientext_"||Departments"
	    if ##class(%Dictionary.CompiledMethod).%ExistsId(classmethod) {
		    do $ClassMethod($piece(classmethod,"||",1),$piece(classmethod,"||",2), $get(pEpis), .pTestSets, $get(pGlb), $get(pFlagPreview))
		    quit
	    }
	}
	
	if $get(pGlb)="" Set pGlb=$Name(^||deptestsets)
	Kill @pGlb
	; Определяем из каких отделов TestSet-ы эпизода 
	Set episobj=##class(User.EPVisitNumber).%OpenId(pEpis,0)
	If '$IsObject(episobj) Quit
	Set key=""
	For  {
		Set testsetobj=episobj.ChildEPVisitTestSet.GetNext(.key)
		If key="" Quit
		If '$IsObject(testsetobj) Continue
		//
		Set testsetid=testsetobj.%Id()
		If (testsetid="") Continue
		
		if (pFlagPreview'="V")&&('..IsPrintable(testsetobj)) Continue ; Пропускаем непечатаемые TestSet-ы
		if (pFlagPreview="V")&&('..IsViewable(testsetobj.%Id())) Continue ; Пропускаем not viewable TestSet-ы
		//
		Set superset=""
		If $IsObject(testsetobj.VISTSSuperSetDR) Set superset=testsetobj.VISTSSuperSetDR.%Id()
		If (superset'="")&&(pFlagPreview'="V")&&('##class(TCLEx.Function.SuperSet).IsComplete(pEpis,superset)) Continue
		//
		If $Data(pTestSets) {
			If (superset'="")&&('$Data(pTestSets(superset)))&&('$Data(pTestSets(testsetid))) Continue
			If (superset="")&&('$Data(pTestSets(testsetid))) Continue
		}	
		//
		Set depcode="",reportgroup=""
		If superset'="" {
			Set depcode=superset
		} Else {
			Set testsetcode=testsetobj.VISTSTestSetDRGetObjectId()
			Set depcode=..GetDepartmentByTestSet(testsetcode)
			Set reportgroup=..ReportGroup(testsetcode)
		}
		If depcode="" Continue
		
		If reportgroup'="" {												// Если набор входит в группу наборов для печати
			Set depcode=##class(TCLEx.Function.TestSet).GetDepartmentByTestSet($Piece(reportgroup,",",1))			// Определяем код отдела для первого набора тестов группы печати
			If depcode="" Continue
			Set $Piece(depcode,$Char(1),3)=reportgroup						
		}		
		Set queueid=##class(TCLEx.Function.TestSet).GetPrintableVerificationQueue(testsetobj)				// Если набор входит в печатаемую очередь			
		If queueid'="" {
			Set $Piece(depcode,$Char(1),2)=queueid
		}
		
		Set @pGlb@(depcode,testsetid)=""
	}
]]></Implementation>
</Method>

<Method name="ReportGroup">
<Description>
Код ГруппыПечати для Кода набора тестов
Параметры:
pTestSet - код группы тестов
Возвращаемое значение:
Пусто, если для набора нет ГруппаПечати.
Перечисление через запятую всех кодов наборов тестов, входящих в группу </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set obj=##class(User.CTTestSet).%OpenId(pTestSet,0)
	If '$IsObject(obj) Quit ""
	Set reportgroup=obj.CTTSReportGroup
	If reportgroup="" Quit ""
	Kill ^||TestSet.ReportGroup
	If pTestSet'="" {
		Set ^||TestSet.ReportGroup(pTestSet)=""
	}
	Set cnt=$Length(reportgroup,",")
	For i=1:1:cnt {
		Set testset=$Piece(reportgroup,",",i)
		If testset'="" {
			Set ^||TestSet.ReportGroup(testset)=""
		}	
	}
	Set result="",testset=""
	For  {
		Set testset=$Order(^||TestSet.ReportGroup(testset))
		If testset="" Quit
		If result'="" Set result=result_","
		Set result=result_testset
	}
	Quit result
]]></Implementation>
</Method>

<Method name="PCLResult">
<Description>
Формирование результатов TestSet-а в виде PCL команда, возвращаемых в ^||testset
Параметры:
pTestSetId - ID наьора тестов
pMaxRowCount - макс. число строк на странице
pFirstOnPage - признак первого на странице набора
pLanguage - язык результата</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pMaxRowCount:%Integer,pFirstOnPage:%Boolean,pLanguage:%String</FormalSpec>
<Implementation><![CDATA[
	Set pLanguage=$Get(pLanguage)
	Kill ^TMP("PRTDR00",$J),^||testset
	Set ^TMP("PRTDR00",$j,"LAN")=$Get(pLanguage)
	
	// если есть клиентская программа print^PRTDR1rus_клиентское расширение, то вызываем ее
	set clientext=$Piece($Get(^CF("SM",1)),"^",28)
	if (clientext'="")&&($length($t(@("print^PRTDR1rus"_clientext)))) {
		xecute "do print^PRTDR1rus"_clientext_"("""_pTestSetId_""","""_"P"_""","""_"H"_""","""_pLanguage_""")" 
	} else {
		Do print^PRTDR1rus(pTestSetId,"P","H",pLanguage) 
	}
	Set i="",j=1
	For  {
		Set i=$Order(^TMP("PRTDR00",$J,"RESULT",i),1,val)
		If i="" Quit
		If $Extract(val,1,1)="!" {
			Set j=j+1
		}
		Set ^||testset(j,$Increment(^||testset(j)))=val
	}
	Do ..RemoveEmptyValues()
	Do ..PCLComments(pTestSetId,pLanguage)
	If pFirstOnPage Do ..RemoveFirstCR($NA(^||testset))
	Do ..PCLAntibiogram(pTestSetId,pMaxRowCount)
]]></Implementation>
</Method>

<Method name="HasPCLResult">
<Description>
Проверка есть ли PCL-результатов  для набора тестов pTestSetId на языке pLanguage
Параметры:
pTestSetId - ID наьора тестов
pLanguage - язык результата</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pLanguage:%String</FormalSpec>
<Implementation><![CDATA[
	If '##class(User.EPVisitTestSet).%ExistsId(pTestSetId) Quit 0
	Kill ^||testset
	Do ..PCLResult(pTestSetId,50,1,pLanguage)
	If $Data(^||testset) Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="PCLAntibiogram">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pMaxRowCount:%Integer</FormalSpec>
<Implementation><![CDATA[
	Set needantibiogram=0
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit
	Set key=""
	For  {
		Set dataobj=testsetobj.ChildEPVisitTestSetData.GetNext(.key)
		If key="" Quit
		If '$IsObject(dataobj) Continue
		If dataobj.ChildEPVisitTestSetDataAntib.Count()>0 { 
			Set needantibiogram=1
			Quit
		}	
	}
	If 'needantibiogram Quit
	Kill ^TMP("PRTDR00",$Job),^||antib
	Do print^PRTDR2RU01(pTestSetId)
	 
	Set i="",j=1 
	For  {
		Set i=$Order(^TMP("PRTDR00",$J,"RESULT",i),1,val)
		If i="" Quit
		If $Extract(val,1,1)="!" {
			Set j=j+1
		}
		Set ^||antib(j,$Increment(^||antib(j)))=val
	}
	If '$Data(^||antib) Quit
	Set testestrows=..LastPageRowCount($NA(^||testset),pMaxRowCount)
	Set antibrows=..FirstPageRowCount($NA(^||antib),pMaxRowCount)
	If (testestrows+antibrows)>pMaxRowCount {						; Перевод на новую страницу, если антибиограмма не влазит на страницу с данными набора тестов
		Set k=$Order(^||testset(""),-1)+1
		Set ^||testset(k,1)=$Char(12)
		Do ..RemoveFirstCR($NA(^||antib))
		/*
		Set k=$Order(^||antib(""))
		If $Get(^||antib(k,1))="~RES-ABP" {
			Kill ^||antib(k,1)
			Do ..RemoveFirstCR($NA(^||antib))
			Set k=$Order(^||antib(""))-1
			Set ^||antib(k,1)="~RES-ABP"
		} Else {
			Do ..RemoveFirstCR($NA(^||antib))
		}*/		
			
	}
	Set k=$Order(^||testset(""),-1)+1								; Дописываем данные антибиограмма в конец данных набора тестов
	Set i=""
	For  {
		Set i=$Order(^||antib(i))
		If i="" Quit
		Merge ^||testset(k)=^||antib(i)
		Set k=k+1 
	}
]]></Implementation>
</Method>

<Method name="RemoveEmptyValues">
<Description>
Удаляем пустые значения полей (есть переоводы строки, но нет текста)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<Implementation><![CDATA[
	Kill ^||tmp										; Сначала формируем временный глобал с разбивкой на переводы строк
	Set i=""
	For  {
		Set i=$Order(^||testset(i))
		If i="" Quit
		Set j="",k=1
		For  {  
			Set j=$Order(^||testset(i,j),1,strval)
			If j="" Quit
			If $Extract(strval,1,1)="?" {
				Set k=k+1	
			}
			Set ^||tmp(i,k,j)=strval
		}
	}
	Kill ^||testset									; Непустые значения записываем обратнов в ^||testset
	Set i=""
	For  {
		Set i=$Order(^||tmp(i))
		If i="" Quit
		Set j="",j2=0
		For  {  
			Set j=$Order(^||tmp(i,j))
			If j="" Quit
			Set k="",wastext=0
			For  {
				Set k=$Order(^||tmp(i,j,k),1,strval)
				If k="" Quit
				If ('wastext) {
					If $Extract(strval,1,1)="?" {
						Set val=$Extract(strval,5,999)
						Set val=$Translate(val," ","")
						Set wastext=(val'="")
					} Else {
						Set val=$Translate(strval," ","")
						Set wastext=(val'="")
					}		
				}
				If wastext Quit
			}
			If 'wastext Continue
			Set k=""
			For  {
				Set k=$Order(^||tmp(i,j,k),1,strval)
				If k="" Quit
				Set j2=j2+1
				Set ^||testset(i,j2)=strval
			}		
			
		}
	}
	
	/*
	For  {
		Set i=$Order(^||tmp(i))
		If i="" Quit
		Set wasquestionmark=0,wastext=1
		Set j=""
		Kill strvals
		For  {  
		
			Set j=$Order(^||tmp(i,j),1,strval)
			If j="" Quit
		
			If $Extract(strval,1,1)="?" {
				Set wasquestionmark=1
				Set val=$Translate($Extract(strval,5,999)," ","")
				Set wastext=(val'="")
				Kill vals
			}
			If wastext Set strvals($Increment(strvals))=strval
		}
	}

	*/
]]></Implementation>
</Method>

<Method name="TemplateTestOrder">
<Description>
Сформировать глобал pTestOrderGlb с порядком тестов в описании шаблона для набора тестов pTestSet</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String,pTestOrderGlb:%String</FormalSpec>
<Implementation><![CDATA[
	Kill @pTestOrderGlb
	&sql(
		DECLARE TestOrderCursor CURSOR FOR
	    Select CTTSF_Order_1,CTTSF_DataItem_DR 
	    Into :order,:test
	    From SQLUser.CT_TestSetFields 
	    Where CTTSF_ParRef=:pTestSet
	)
	&sql(OPEN TestOrderCursor)
	&sql(FETCH TestOrderCursor)

	While (SQLCODE = 0) {
	If (order'="")&&(test'="")&&(##class(User.CTTestCode).%ExistsId(test)) {
		Set @pTestOrderGlb@(test)=order
	} 	
	&sql(FETCH TestOrderCursor)
	}
	&sql(CLOSE TestOrderCursor)
]]></Implementation>
</Method>

<Method name="TemplateTestOrder2">
<Description>
Сформировать глобал pTestOrderGlb с порядком тестов в описании шаблона для набора тестов pTestSet
брать только печатаемые (Reportable) тесты</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String,pTestOrderGlb:%String</FormalSpec>
<Implementation><![CDATA[
	Kill @pTestOrderGlb
	&sql(
		DECLARE TestOrderCursor2 CURSOR FOR
	    Select CTTSF_Order_1,CTTSF_DataItem_DR 
	    Into :order,:test
	    From SQLUser.CT_TestSetFields 
	    Where CTTSF_ParRef=:pTestSet and CTTSF_Reportable='Y'
	)
	&sql(OPEN TestOrderCursor2)
	&sql(FETCH TestOrderCursor2)

	While (SQLCODE = 0) {
	If (order'="")&&(test'="")&&(##class(User.CTTestCode).%ExistsId(test)) {
		Set @pTestOrderGlb@(test)=order
	} 	
	&sql(FETCH TestOrderCursor2)
	}
	&sql(CLOSE TestOrderCursor2)
]]></Implementation>
</Method>

<Method name="TestSetDataIdOrder">
<Description>
Сформировать глобал pDataIdOrderGlb с порядком ID данных набора тестов по pTestSetId - Id набора тестов и pTestOrderGlb - порядку тестов в шаблоне для набора тестов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pTestOrderGlb:%String,pDataIdOrderGlb:%String</FormalSpec>
<Implementation><![CDATA[
	Kill @pDataIdOrderGlb
	&sql(
		DECLARE TestDataOrderCursor CURSOR FOR
	    Select VISTD_TestCode_DR,VISTD_RowId 
	    Into :testcode,:testdataid
	    From SQLUser.EP_VisitTestSetData 
	    Where VISTD_ParRef=:pTestSetId
	)
	&sql(OPEN TestDataOrderCursor)
	&sql(FETCH TestDataOrderCursor)

	While (SQLCODE = 0) {
	If (testcode'="")&&(testdataid'="") {
		Set order=$Get(@pTestOrderGlb@(testcode))
		If order'="" {
			Set @pDataIdOrderGlb@(order,testdataid)=testcode
		}
	} 	
	&sql(FETCH TestDataOrderCursor)
	}
	&sql(CLOSE TestDataOrderCursor)
]]></Implementation>
</Method>

<Method name="PCLComments">
<Description>
Добавить комментарии по набору тестов pTestSetId
Результат в ^||comments</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pLanguage:%String</FormalSpec>
<Implementation><![CDATA[
	// Если существует класс TCLEx.Funclion.TestSet(расширение для клиента) и в нем существует метод Departments, то вызывается клиентский метод 
	set clientext=$Piece($Get(^CF("SM",1)),"^",28)
	if (clientext'="") {
		set classmethod=$CLASSNAME()_clientext_"||PCLComments"
	    if ##class(%Dictionary.CompiledMethod).%ExistsId(classmethod) {
		    do $ClassMethod($piece(classmethod,"||",1),$piece(classmethod,"||",2), $get(pTestSetId), $get(pLanguage))
		    quit
	    }
	}
	
	Set pLanguage=$Get(pLanguage)
	; Добавляем комментарии
	Kill ^||comments
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit
	Set testsetcode=testsetobj.VISTSTestSetDRGetObjectId()
	If testsetcode="" Quit
	//
	Kill ^||TestSet.TestOrder
	Do ..TemplateTestOrder(testsetcode,$Name(^||TestSet.TestOrder))
	Kill ^||TestSet.DataIdOrder
	Do ..TestSetDataIdOrder(pTestSetId,$Name(^||TestSet.TestOrder),$Name(^||TestSet.DataIdOrder))
	Set order=""
	For  {
		Set order=$Order(^||TestSet.DataIdOrder(order))
		If order="" Quit
		
		Set testdataid=""
		For  {
			Set testdataid=$Order(^||TestSet.DataIdOrder(order,testdataid),1,testcodeid)
			If testdataid="" Quit
			;If testcodeid="" Continue
			Set dataobj=##class(User.EPVisitTestSetData).%OpenId(testdataid)
			If ('$IsObject(dataobj))||('$IsObject(dataobj.VISTDComments)) Continue
			Set cnt=dataobj.VISTDComments.Count()
			If cnt=0 Continue
			If (testcodeid'="") {
				Set commentheader=""
				&sql(
					Select CTTSF_CommentHeading Into :commentheader from SQLUser.CT_TestSetFields where (CTTSF_ParRef=:testsetcode)and(CTTSF_DataItem_DR=:testcodeid)
				)
				If commentheader'="" {
					Set translatedheader=""
					If (testsetcode'="")&&(pLanguage'="") {
						Set translatedheader=$Get(^TTAB("TS",testsetcode,"LAN",pLanguage,commentheader))
					}
					Kill comment
					Set comment(1)=$Select(translatedheader'="":translatedheader,1:commentheader)
					Merge ^||comments($I(^||comments))=comment
				}	
			}	
			For i=1:1:cnt {
				Kill comment
				Set strval=dataobj.VISTDComments.GetAt(i)
				Set commentobj="",textobj=""
				If (strval["[")&&(strval["]") {
					Set n=$Piece($Piece(strval,"[",2),"]",1)
					Set textobj=""
					If (pLanguage'="")&&(##class(User.CTTestCodeStComTransl).%ExistsId(testcodeid_"||"_n_"||"_pLanguage)) {
						Set commentobj=##class(User.CTTestCodeStComTransl).%OpenId(testcodeid_"||"_n_"||"_pLanguage,0)
						If $IsObject(commentobj) {
							Set textobj=commentobj.CTTCEText
						}
					}	
					If '$IsObject(textobj) {
						Set commentobj=##class(User.CTTestCodeStandardComm).%OpenId(testcodeid_"||"_n,0)
						If $IsObject(commentobj) {
							Set textobj=commentobj.CTTCTText
						}
					}
				}	
				If $IsObject(textobj) {
					Set cnt2=textobj.Count()
					For j=1:1:cnt2 Set comment(j)=textobj.GetAt(j)
				} Else {
					Set comment(1)=strval
				}
				Merge ^||comments($I(^||comments))=comment
			}
		}	
	
	}
	Set i=""
	For  {
		Set i=$Order(^||comments(i))
		If i="" Quit
		If i=1 {								; Отступ от данных TestSet-а
			Set k=$Order(^||testset(""),-1)+1
			Set ^||testset(k,$Increment(^||testset(k)))="!"
		}	
		
		Set j=""
		For  {
			Set j=$Order(^||comments(i,j),1,strval)
			If j="" Quit
			Set k=$Order(^||testset(""),-1)+1
			Kill vals
			Do ..TruncateStr(strval,80,.vals)
			Set l=""
			For  {
				Set l=$Order(vals(l),1,val)
				If l="" Quit
				Set ^||testset(k,$Increment(^||testset(k)))="!"
				Set ^||testset(k,$Increment(^||testset(k)))="?10 "
				Set ^||testset(k,$Increment(^||testset(k)))=val
				Set k=k+1
			}
		}
	}
]]></Implementation>
</Method>

<Method name="PCLComments2">
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<PublicList>testsetcode,tescodeid,SQLCODE</PublicList>
<Implementation><![CDATA[
	; Добавляем комментарии
	Kill ^||comments
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit
	Set testsetcode=testsetobj.VISTSTestSetDR.%Id()
	Set key=""
	For  {
		Set dataobj=testsetobj.ChildEPVisitTestSetData.GetNext(.key)
		If key="" Quit
		If '$IsObject(dataobj) Continue
		If '$IsObject(dataobj.VISTDComments) Continue
		Set cnt=dataobj.VISTDComments.Count()
		If cnt=0 Continue
		Set tescodeid=""
		If $IsObject(dataobj.VISTDTestCodeDR) Set tescodeid=dataobj.VISTDTestCodeDR.%Id()
		If (tescodeid'="") {
			Set commentheader=""
			&sql(
				Select CTTSF_CommentHeading Into :commentheader from SQLUser.CT_TestSetFields where (CTTSF_ParRef=:testsetcode)and(CTTSF_DataItem_DR=:tescodeid)
			)
			If commentheader'="" {
				If '$Data(^||comments) {
					Set ^||comments($I(^||comments),1)=""
				}	
				Kill comment
				Set comment(1)=""
				Set comment(2)=commentheader
				Merge ^||comments($I(^||comments))=comment
			}	
		}	
		For i=1:1:cnt {
			Kill comment
			Set strval=dataobj.VISTDComments.GetAt(i)
			Set commentobj=""
			If (strval["[")&&(strval["]") {
				Set n=$Piece($Piece(strval,"[",2),"]",1)
				If +n=n Set commentobj=##class(User.CTTestCodeStandardComm).%OpenId(tescodeid_"||"_n)
			}	
			If $IsObject(commentobj)&&$IsObject(commentobj.CTTCTText) {
				Set cnt2=commentobj.CTTCTText.Count()
				For j=1:1:cnt2 Set comment(j)=commentobj.CTTCTText.GetAt(j)
			} Else {
				Set comment(1)=strval
			}
			Merge ^||comments($I(^||comments))=comment
		}
	}	
	Set i=""
	For  {
		Set i=$Order(^||comments(i))
		If i="" Quit
		If i=1 {								; Отступ от данных TestSet-а
			Set k=$Order(^||testset(""),-1)+1
			Set ^||testset(k,$Increment(^||testset(k)))="!"
		}	
		
		Set j=""
		For  {
			Set j=$Order(^||comments(i,j),1,strval)
			If j="" Quit
			Set k=$Order(^||testset(""),-1)+1
			Kill vals
			Do ..TruncateStr(strval,80,.vals)
			Set l=""
			For  {
				Set l=$Order(vals(l),1,val)
				If l="" Quit
				Set ^||testset(k,$Increment(^||testset(k)))="!"
				Set ^||testset(k,$Increment(^||testset(k)))="?10 "
				Set ^||testset(k,$Increment(^||testset(k)))=val
				Set k=k+1
			}
		}
	}
]]></Implementation>
</Method>

<Method name="TruncateStr">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pStrVal:%String,pMaxLength:%Integer,&pResult:%String]]></FormalSpec>
<Implementation><![CDATA[
	Set len=$Length(pStrVal)
	If len'>pMaxLength {
		Set pResult(1)=pStrVal
		Quit
	}
	Set exit=0,str="",word=""
	For i=1:1:len {
		Set char=$Extract(pStrVal,i,i)
		If (char=" ")||(char="-") {
			If ($Length(str)+$Length(word))<pMaxLength {
				Set str=str_word_char
				Set word=""
			} Else {
				Set pResult($Increment(pResult))=str
				Set str=word_char
				Set word=""
			}
		} Else {
			If $Length(word)<pMaxLength {
				Set word=word_char
			} Else {
				If str'="" {
					Set pResult($Increment(pResult))=str
					Set pResult($Increment(pResult))=$Extract(word,1,pMaxLength)
					Set str=""
					Set word=$Extract(word,pMaxLength+1,$Length(word))_char
					
				} Else {
					Set pResult($Increment(pResult))=$Extract(word,1,pMaxLength)
					Set str=""
					Set word=$Extract(word,pMaxLength+1,$Length(word))_char
				
				}		
			}	
				
		}		
	}
	If (str'="")||(word'="") {
		If ($Length(str)+$Length(word))>pMaxLength {
			Set pResult($Increment(pResult))=str	
			Set pResult($Increment(pResult))=word	
		} Else {
			Set pResult($Increment(pResult))=str_word
			
		}		
	}
]]></Implementation>
</Method>

<Method name="TotalRowCount">
<Description>
Полное число строк в результате (пропускаем переводы на новую страницу)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlb:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set result=0
	Set i=""
	For  {
		Set i=$Order(@pGlb@(i))
		If i="" Quit
		If $Get(@pGlb@(i,1))'=$Char(12) Set result=result+1
	}
	Quit result
]]></Implementation>
</Method>

<Method name="FirstPageRowCount">
<Description>
Полное число строк в результате на первой странице 
Выход из цикла подсчета строк:
1) по окончанию узлов (результат - число узлов)
2) если встретился перевод строки (результат - число узлов до первода строки)
3) если достигнуто максимальное число на странице (результат - максимальное число строк на странице)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlb:%String,pMaxRowCount:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set result=0
	Set i=""
	For  {
		Set i=$Order(@pGlb@(i))
		If i="" Quit
		If $Get(@pGlb@(i,1))=$Char(12) Quit
		Set result=result+1
		If result=pMaxRowCount Quit
	}
	Quit result
]]></Implementation>
</Method>

<Method name="LastPageRowCount">
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlb:%String,pMaxRowCount:%Integer</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Set i="",startpagenode="",prevnode=""								; Сначала пробегаем с конца по глобалу, чтобы определить были ли переводы строк
	For  {
		Set i=$Order(@pGlb@(i),-1)
		If i="" Quit
		If $Get(@pGlb@(i,1))=$Char(12) {
			Set startpagenode=i
			Quit
		}	
	}
	Set result=0,i=""
	For  {
		Set i=$Order(@pGlb@(i),-1)
		If (i="")||(i=startpagenode) Quit
		Set result=result+1
	}
	If result>pMaxRowCount Quit result#pMaxRowCount						; Если всего строк больше, чем макимальное кол-во, то возвращаем остаток от деления на pMaxRowCount
	Quit result
]]></Implementation>
</Method>

<Method name="LogAuthorisationStatus">
<Description>
Регистрация авторизации\деавторизации набора тестов для последующих действий (отправка E-Mail, передача результата в WebER...)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisId:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	If (pEpisId="")||(pTestSetId="") Quit
	;
	Set dateoflastchange=$Get(pValues(75))
	Set timeoflastchange=$Get(pValues(76))
	;
	Set dateofauthorisation=$Get(pValues(7))
	Set timeofauthorisation=$Get(pValues(8))
	Set authoriseddoctor=$Get(pValues(9))
	
	;
	Set reason=$Get(pValues(58))
	Set dateofreason=$Get(pValues(59))
	Set timeofreason=$Get(pValues(60))
	Set superset=$Get(pValues(32)),iscompletesuperset=0
	If superset'="" {
		Set iscompletesuperset=##class(TCLEx.Function.SuperSet).IsComplete(pEpisId,superset,.firsttestsetid)
		Set pTestSetId=superset
		Do ##class(TCLEx.Function.SuperSet).UpdatePrintQueueBuffer(pEpisId,superset,iscompletesuperset,authoriseddoctor)

	}	
	;
	Set needadd=0
	If (dateoflastchange=dateofauthorisation)&&((timeoflastchange/60\1)=timeofauthorisation) { ; Если была авторизация (время авторицации в числе минут, поэтому преобразуем время изменения, которое в секундах)
		Set needadd=1
	} ElseIf ..IsJustCanceled(pEpisId,pTestSetId,.pValues,.pOldValues) { //(dateoflastchange=dateofreason)&&(timeoflastchange=timeofreason) {					; Если была отмена набора тестов 
		If (superset'="")&&(iscompletesuperset) {											// Для завершенных супер-наборов любая
			Set needadd=1
		} Else {	
			Set reasonobj=##class(User.CTReason).%OpenId(reason)
			If $IsObject(reasonobj)&&(reasonobj.CTRReportable="Y") {						// Для обычных наборов тестов печатаемая
				Set needadd=1
			}
		}
	}		 
	If (needadd)&&(superset'="")&&('iscompletesuperset) {
		Set needadd=0
	}	
	//
	Set needdel=0
	Set status=$Get(pValues(33))
	Set oldstatus=$Get(pOldValues(33))
	If (status="E")&&((oldstatus="A")||(oldstatus="")) { // Была деавторизация набора тестов (иногда старый значение становится пусто, а не "А")
		Set needdel=1
	}	
	If ('needadd)&&('needdel) Quit
	Do ##class(TCLEx.Function.LabOrder).NeededResultModes(pEpisId,.needweber,.needhospitalemail,.needpatientemail,.needpatientsms,.extlabvals)
	If (needadd) {
		Set hor=$Horolog
		Do ..SetAuthorisationStatus(pEpisId,pTestSetId,hor,hor,needweber,needhospitalemail,needpatientemail,needpatientsms,extlabvals)
	}	
	If (needdel) {
		Do ..KillAuthorisationStatus(pEpisId,pTestSetId,extlabvals)
	}
]]></Implementation>
</Method>

<Method name="RemoveFirstCR">
<ClassMethod>1</ClassMethod>
<FormalSpec>pGlb:%String</FormalSpec>
<Implementation><![CDATA[
	Kill ^||tmp
	Merge ^||tmp=@pGlb
	Kill @pGlb
	Set i="",i2=0,wastext=0
	For  {
		Set i=$Order(^||tmp(i))
		If i="" Quit
		If wastext Set i2=i2+1
		Set j="",j2=0
		For  {
			Set j=$Order(^||tmp(i,j),1,val)
			If j="" Quit
			If 'wastext {
				If $Extract(val,1,1)="!" {
					Set val2=$Extract(val,2,$Length(val))
					If val2'="" Set wastext=1
				} Else {
					Set wastext=1
				}
				If wastext Set i2=1		
			}
			If wastext {
				Set j2=j2+1
				Set @pGlb@(i2,j2)=val
			}	
		}	
	}
]]></Implementation>
</Method>

<Method name="SetAuthorisationStatus">
<Description>
Записываем статус авторизации для эпизода pEpisId набора тестов pTestSetId </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisId:%String,pTestSetId:%String,pEpisDateTime:%String,pTestSetDateTime:%String,pWebER:%Boolean,pHospitalEMail:%Boolean,pPatientEMail:%Boolean,pPatientSMS:%Boolean,pExtLabVals:%String</FormalSpec>
<Implementation><![CDATA[
	Set pEpisDateTime=$Get(pEpisDateTime,$Horolog)
	Set pTestSetDateTime=$Get(pTestSetDateTime,$Horolog)
	If (pWebER) {												// Для передачи результатов в WebER
		Lock +^TCLEx("AuthorizedEpisodes",pEpisId)
		Set episdatetime=$Get(^TCLEx("AuthorizedEpisodes",pEpisId))		
		If (episdatetime="")||(episdatetime]pEpisDateTime) Set ^TCLEx("AuthorizedEpisodes",pEpisId)=pEpisDateTime
		Lock -^TCLEx("AuthorizedEpisodes",pEpisId)
	}
	If ..IsConfidentional(pTestSetId) Quit 						// Выход, если не нужно печатать, отсылать по E-Mail,SMS и т.д.
	If (pHospitalEMail) {										// Для отсылки EMail ЛПУ
		Lock +^TCLEx("E-Mail",pEpisId)
		Set ^TCLEx("E-Mail",pEpisId,pTestSetId)=pTestSetDateTime
		Set episdatetime=$Get(^TCLEx("E-Mail",pEpisId))		
		If (episdatetime="")||(episdatetime]pEpisDateTime) Set ^TCLEx("E-Mail",pEpisId)=pEpisDateTime
		Lock -^TCLEx("E-Mail",pEpisId)
	}
	If (pPatientEMail) {										// Для отсылки EMail пациенту
		Lock +^TCLEx("PatientEMail",pEpisId)
		Set ^TCLEx("PatientEMail",pEpisId,pTestSetId)=pTestSetDateTime
		Set episdatetime=$Get(^TCLEx("PatientEMail",pEpisId))		
		If (episdatetime="")||(episdatetime]pEpisDateTime) Set ^TCLEx("PatientEMail",pEpisId)=pEpisDateTime
		Lock -^TCLEx("PatientEMail",pEpisId)
	}
	If (pPatientSMS) {											// Для отсылки SMS пациенту
		Lock +^TCLEx("PatientSMS",pEpisId)
		Set ^TCLEx("PatientSMS",pEpisId,pTestSetId)=pTestSetDateTime
		Set episdatetime=$Get(^TCLEx("PatientSMS",pEpisId))		
		If (episdatetime="")||(episdatetime]pEpisDateTime) Set ^TCLEx("PatientSMS",pEpisId)=pEpisDateTime
		Lock -^TCLEx("PatientSMS",pEpisId)
	}
	If (pExtLabVals'="") {
		Set extlab=$ListGet(pExtLabVals,1)
		Set extepis=$ListGet(pExtLabVals,2)
		If (extlab'="")&&(extepis'="") {
			Lock +^TCLEx("External",extlab,pEpisId)
			Set ^TCLEx("External",extlab,pEpisId)=extepis
			Set ^TCLEx("External",extlab,pEpisId,pTestSetId)=pTestSetDateTime
			Lock -^TCLEx("External",extlab,pEpisId)
		}
	}
]]></Implementation>
</Method>

<Method name="KillAuthorisationStatus">
<Description>
Удаляем статус авторизации для эпизода pEpisId набора тестов pTestSetId</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisId:%String,pTestSetId:%String,pExtLabVals:%String</FormalSpec>
<Implementation><![CDATA[
	If $Data(^TCLEx("AuthorizedEpisodes",pEpisId)) {
		Lock +^TCLEx("AuthorizedEpisodes",pEpisId)
		Kill ^TCLEx("AuthorizedEpisodes",pEpisId)
		Lock -^TCLEx("AuthorizedEpisodes",pEpisId)
	}

	If $Data(^TCLEx("E-Mail",pEpisId,pTestSetId)) {
		Lock +^TCLEx("E-Mail",pEpisId)
		Kill ^TCLEx("E-Mail",pEpisId,pTestSetId)
		If $Data(^TCLEx("E-Mail",pEpisId))=1 {
			Kill ^TCLEx("E-Mail",pEpisId)
		}	
		Lock -^TCLEx("E-Mail",pEpisId)
	}
	If $Data(^TCLEx("PatientEMail",pEpisId,pTestSetId)) {
		Lock +^TCLEx("PatientEMail",pEpisId)
		Kill ^TCLEx("PatientEMail",pEpisId,pTestSetId)
		If $Data(^TCLEx("PatientEMail",pEpisId))=1 {
			Kill ^TCLEx("PatientEMail",pEpisId)
		}	
		Lock -^TCLEx("PatientEMail",pEpisId)
	}
	If $Data(^TCLEx("PatientSMS",pEpisId,pTestSetId)) {
		Lock +^TCLEx("PatientSMS",pEpisId)
		Kill ^TCLEx("PatientSMS",pEpisId,pTestSetId)
		If $Data(^TCLEx("PatientSMS",pEpisId))=1 {
			Kill ^TCLEx("PatientSMS",pEpisId)
		}	
		Lock -^TCLEx("PatientSMS",pEpisId)
	}
	If (pExtLabVals'="") {
		Set extlab=$ListGet(pExtLabVals,1)
		Set extepis=$ListGet(pExtLabVals,2)
		If (extlab'="")&&(extepis'="") {
			Lock +^TCLEx("External",extlab,pEpisId)
			If $Data(^TCLEx("External",extlab,pEpisId,pTestSetId)) {
				Kill ^TCLEx("External",extlab,pEpisId,pTestSetId)
			}
			If $Data(^TCLEx("External",extlab,pEpisId))=1 {
				Kill ^TCLEx("External",extlab,pEpisId)
			}	
			Lock -^TCLEx("External",extlab,pEpisId)
		}
	}
]]></Implementation>
</Method>

<Method name="ResendResult">
<Description>
Повторная отправка результатов </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisId:%String,pTestSetId:%String</FormalSpec>
<Implementation><![CDATA[
	If ($Get(pEpisId)="")||($Get(pTestSetId)="") Quit
	Do ##class(TCLEx.Function.LabOrder).NeededResultModes(pEpisId,.needweber,.needhospitalemail,.needpatientemail,.needpatientsms)
	Set cito=##class(TCLEx.Function.Episode).IsCito(pEpisId)
	; Тайм-ауты для отправки результата
	If cito {																	; Для CITO
		Set episdeltatime=$$CitoEpisodeTimeOut^Settings.EMail() 				; Сколько ждем с момента  первой авторизации TestSet-а эпизода или последней выгрузки результатов по эпизоду 
		Set testsetdeltatime=$$CitoTestSetTimeOut^Settings.EMail()				; Сколько ждем с момента после авторизации TestSet-а						
	}
	Else {
		Set episdeltatime=$$EpisodeTimeOut^Settings.EMail()
		Set testsetdeltatime=$$TestSetTimeOut^Settings.EMail()
	}			
	Set episdatetime=$ZDateTimeH($System.SQL.DATEADD("ss",-1*episdeltatime+60,$Horolog),3)
	Set testsetdatetime=$ZDateTimeH($System.SQL.DATEADD("ss",-1*testsetdeltatime+60,$Horolog),3)
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit
	Set superset=""
	If $IsObject(testsetobj.VISTSSuperSetDR) {
		Set superset=testsetobj.VISTSSuperSetDR.%Id()
		If '##class(TCLEx.Function.SuperSet).IsComplete(pEpisId,superset) Quit
		Set pTestSetId=superset
	}	
	Do ..SetAuthorisationStatus(pEpisId,pTestSetId,episdatetime,testsetdatetime,1,needhospitalemail,needpatientemail,needpatientsms)
]]></Implementation>
</Method>

<Method name="IsConfidentional">
<Description>
Является ли набор тестов pTestSetId конфиденциальный (т.е. не печатается) </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If ##class(User.CTSuperSet).%ExistsId(pTestSetId) Quit 0 		// Выход, если это супер-набор
	&sql(
		Declare ConfCursor CURSOR FOR
	    Select VISTD_SupressReport
	    Into :supress
	    From SQLUser.EP_VISITTESTSETDATA
	    Where VISTD_ParRef=:pTestSetId
	)

	&sql(Open ConfCursor)
	&sql(Fetch ConfCursor)
	If SQLCODE=100 Quit 0											// Нет записей для этого набора тестов
	Set result=1
	While (SQLCODE = 0) {
		If supress'="Y" {
			Set result=0
			Quit
		}	
		&sql(Fetch ConfCursor)
	}
	&sql(Close ConfCursor)
	Quit result
]]></Implementation>
</Method>

<Method name="IsConfidentional2">
<Description>
Является ли набор тестов pTestSetId конфиденциальный (т.е. не печатается) </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If ##class(User.CTSuperSet).%ExistsId(pTestSetId) Quit 0
	Set testset=$Piece(pTestSetId,"||",2)
	If testset="" Quit 0
	If (testset'="E225")&&(testset'="E901")&&(testset'="E230") Quit 0
	Kill ^TMP("PRTDR00",$J)
	Do print^PRTDR1SPB02(pTestSetId,"P","H")
	If $Data(^TMP("PRTDR00",$J)) Quit 0
	Quit 1
]]></Implementation>
</Method>

<Method name="GetResultInfo">
<Description>
Формирование буфера pGlb с отображаемым результатом по набору тестов pTestSetId</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pLanguage:%String,pGlb:%String</FormalSpec>
<PublicList>PLIST</PublicList>
<Implementation><![CDATA[
	// Если существует класс TCLEx.Funclion.TestSet(расширение для клиента) и в нем существует метод GetResultInfo, то вызывается клиентский метод 
	set clientext=$Piece($Get(^CF("SM",1)),"^",28)
	if (clientext'="") {
		set classmethod=$CLASSNAME()_clientext_"||GetResultInfo"
	    if ##class(%Dictionary.CompiledMethod).%ExistsId(classmethod) {
		    do $ClassMethod($piece(classmethod,"||",1),$piece(classmethod,"||",2), $get(pTestSetId), $get(pLanguage), $get(pGlb))
		    quit
	    }
	}
	
	Set pLanguage=$Get(pLanguage)
	Kill @pGlb
	Kill PLIST,DataIds
	Set sqlcode=$$results^LVBVISTS(pTestSetId,"","N")
	Set i=""
	For  {
		Set i=$Order(PLIST(i),1,vals)
		If i="" Quit
		Set tsdataid=$Piece(vals,$Char(1),1)
		Set code=$Piece(vals,$Char(1),2)
		If (tsdataid="")||(code="") Continue
		Set DataIds(code)=tsdataid
		Set @pGlb@(tsdataid,"SequenceNumber")=i
		Set @pGlb@(tsdataid,"Code")=code
		Set @pGlb@(tsdataid,"RawValue")=$Piece(vals,$Char(1),3)
		Set @pGlb@(tsdataid,"FreeText")=$$RemomeNotPrintableCharacters^KSUTIL1($Piece(vals,$Char(1),4))
		Set @pGlb@(tsdataid,"AnalyzerId")=$Piece(vals,$Char(1),24) // ????
		Set flag=$Piece(vals,$Char(1),5)
		Set @pGlb@(tsdataid,"Flag")=flag
		If (flag="A")||(flag="H")||(flag="L") {
			Set @pGlb@(tsdataid,"Abnormal")=1
		}
		Set @pGlb@(tsdataid,"Panic")=$Piece(vals,$Char(1),7)
	}
	If pLanguage="" {
		Set pLanguage=$Piece($Get(^CF("SM",1)),"^",10)
	}	
	//Set language=$Piece($Get(^CF("SM",1)),"^",10)
	Kill PLIST
	Set sqlcode=$$getit^LVBCTTSF(,pTestSetId,"Y",,,"",,pLanguage)
	Set i=""
	For  {
		Set i=$Order(PLIST(i),1,vals)
		If i="" Quit
		Set code=$Piece(vals,$Char(2),10)
		If (code="")||('$Data(DataIds(code))) Continue
		Set tsdataid=$Get(DataIds(code))
		If tsdataid="" Continue
		Set value=$Get(@pGlb@(tsdataid,"RawValue"))
		Set type=$Piece(vals,$Char(2),18)
		If ((type="S")||(type="B1"))&&(value'="") {
			If (pLanguage'="")&&($Data(^TTAB("TC",code,"2L",value,pLanguage,"T"))) {
				Set codevalue=value
				Set value=""
				Set j=""
				For {
					Set j=$Order(^TTAB("TC",code,"2L",codevalue,pLanguage,"T",j),1,val)
					If j="" Quit
					If j=0 Continue
					If (value'="")&&('$$PunctuationCharacter^KSUTIL1($Extract(value,$Length(value)))) {
						Set value=value_" "
					}
					Set value=value_val	
				}
			} ElseIf $Data(^TTAB("TC",code,2,value,"T")) {
				Set codevalue=value
				if $get(^TTAB("TC",code,2,codevalue,"T",0))'="" {
					Set value=codevalue
				}
				/*
				Set j=""
				For {
					Set j=$Order(^TTAB("TC",code,2,codevalue,"T",j),1,val)
					If j="" Quit
					If j=0 Continue
					If (value'="")&&('$$PunctuationCharacter^KSUTIL1($Extract(value,$Length(value)))) {
						Set value=value_" "
					}
					Set value=value_val	
				} */
			}
		}
		If (type="X")&&(value="") {
			Set value=$Get(@pGlb@(tsdataid,"FreeText"))
		}
		If (type="V") {
			Set value=$Piece($Get(^TTAB("BUG",value)),"\",1)
		}		
		Set @pGlb@(tsdataid,"Value")=value
		Set @pGlb@(tsdataid,"Description")=$Piece(vals,$Char(2),3)
		Set @pGlb@(tsdataid,"Units")=$Piece(vals,$Char(2),17)
		Set @pGlb@(tsdataid,"MinRange")=$Piece(vals,$Char(2),22)
		Set @pGlb@(tsdataid,"MaxRange")=$Piece(vals,$Char(2),23)
		
		Set dataobj=##class(User.EPVisitTestSetData).%OpenId(tsdataid)
		If ($IsObject(dataobj))&&($IsObject(dataobj.VISTDComments)) {
			Set comment=""
			Set cnt=dataobj.VISTDComments.Count()
			For j=1:1:cnt {
				Set str=dataobj.VISTDComments.GetAt(j)
				Set complexrefranges=..IsComplexReferenceRanges(str)
				Do ..CommentBuffer(code,str,pLanguage,.vals)
				Set n=""
				For  {
					Set n=$Order(vals(n),1,value)
					If n="" Quit
					If complexrefranges {
						Set @pGlb@(tsdataid,"ComplexRefRanges",$Increment(@pGlb@(tsdataid,"CommentStrings")))=value
					} Else {			
						If (comment'="")&&('$$PunctuationCharacter^KSUTIL1($Extract(value,$Length(value)))) {
							Set comment=comment_" "
						}
						Set comment=comment_value	
						Set @pGlb@(tsdataid,"CommentStrings",$Increment(@pGlb@(tsdataid,"CommentStrings")))=value
					}
				}
					
			}
			Set @pGlb@(tsdataid,"Comment")=comment
		}	
	}
]]></Implementation>
</Method>

<Method name="IsComplexReferenceRanges">
<Description>
Является ли кодом стандартного комментария, которому соответствуют сложные референсные границы
(код начинается на REF)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCommentCode:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set result=0
	Set pCommentCode=$Translate(pCommentCode,"{}","[]")
	If (pCommentCode["[")&&(pCommentCode["]") {
		Set code=$Piece($Piece(pCommentCode,"[",2),"]",1)
		If $Extract(code,1,3)="REF" {
			Set result=1
		}	
	}
	Quit result
]]></Implementation>
</Method>

<Method name="CommentBuffer">
<Description>
Формирование буфера pResult со строками стандартного комментария
Параметры:
pTestCode - код теста
pCommentCode - код комментария
pLanguage - язык результата
pResult - буфер со строками результата</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestCode:%String,pCommentCode:%String,pLanguage:%String,pResult:%String</FormalSpec>
<Implementation><![CDATA[
	Set pLanguage=$Get(pLanguage)
	Kill pResult
	Set commentobj="",textobj="",result=""
	Set originalvalue=pCommentCode
	Set pCommentCode=$Translate(pCommentCode,"{}","[]")
	If (pCommentCode["[")&&(pCommentCode["]") {
		Set n=$Piece($Piece(pCommentCode,"[",2),"]",1)
		Set textobj=""
		If (pLanguage'="")&&(##class(User.CTTestCodeStComTransl).%ExistsId(pTestCode_"||"_n_"||"_pLanguage)) {
			Set commentobj=##class(User.CTTestCodeStComTransl).%OpenId(pTestCode_"||"_n_"||"_pLanguage,0)
			If $IsObject(commentobj) {
				Set textobj=commentobj.CTTCEText
			}
		}	
		If '$IsObject(textobj) {
			Set commentobj=##class(User.CTTestCodeStandardComm).%OpenId(pTestCode_"||"_n,0)
			If $IsObject(commentobj) {
				Set textobj=commentobj.CTTCTText
			}
		}
	}	
	If $IsObject(textobj) {
		Set cnt2=textobj.Count()
		For j=1:1:cnt2 {
			Set val=textobj.GetAt(j)
			Set pResult($Increment(pResult))=..DecodeCommentCharacters(val)
		}	
	} Else {
		Set pResult($Increment(pResult))=..DecodeCommentCharacters(originalvalue)
	}
]]></Implementation>
</Method>

<Method name="CommentValue">
<Description>
!!! CommentValue больше не должен использоваться!!! Вместо него сначала формируем буфер со строками в CommentBuffer
Формирование буфера pGlb с отображаемым результатом по набору тестов pTestSetId</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestCode:%String,pCommentCode:%String,pLanguage:%String</FormalSpec>
<Implementation><![CDATA[
	Set pLanguage=$Get(pLanguage)
	Set commentobj="",textobj="",result=""
	Set pCommentCode=$Translate(pCommentCode,"{}","[]")
	If (pCommentCode["[")&&(pCommentCode["]") {
		Set n=$Piece($Piece(pCommentCode,"[",2),"]",1)
		Set textobj=""
		If (pLanguage'="")&&(##class(User.CTTestCodeStComTransl).%ExistsId(pTestCode_"||"_n_"||"_pLanguage)) {
			Set commentobj=##class(User.CTTestCodeStComTransl).%OpenId(pTestCode_"||"_n_"||"_pLanguage,0)
			If $IsObject(commentobj) {
				Set textobj=commentobj.CTTCEText
			}
		}	
		If '$IsObject(textobj) {
			Set commentobj=##class(User.CTTestCodeStandardComm).%OpenId(pTestCode_"||"_n,0)
			If $IsObject(commentobj) {
				Set textobj=commentobj.CTTCTText
			}
		}
	}	
	If $IsObject(textobj) {
		Set cnt2=textobj.Count()
		For j=1:1:cnt2 {
			Set val=textobj.GetAt(j)
			If (result'="")&&('$$PunctuationCharacter^KSUTIL1($Extract(val,$Length(val)))) {
				Set result=result_" "
			}
			Set result=result_val
		}	
	} Else {
		Set result=pCommentCode
	}
	Set result=..DecodeCommentCharacters(result)
	Quit result
]]></Implementation>
</Method>

<Method name="DecodeCommentCharacters">
<Description>
Декодировать знчение коментария (ряд символов пунктуации при хранении меняется на непечатные символы)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCommentCode:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set result=$Translate(pCommentCode,$Char(16,5,6,11,12,18,17),"^{}[]|\")
	Quit result
]]></Implementation>
</Method>

<Method name="IsJustCanceled">
<Description>
Была ли только что отмена  набора тестов при вызове триггера для эпизода pEpisode, Id набора тестов  pTestSetId, новых значений pValues, старых значений pOldValues</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	If (pEpisode="")||(pTestSetId="") Quit 0
	//
	Set reason=$Get(pValues(58))
	If reason="" Quit 0								
	//
	Set oldreason=$Get(pOldValues(58))							 
	If oldreason=""  Quit 1							
	Quit 0
]]></Implementation>
</Method>

<Method name="DepartmentCode">
<Description>
Код отдела для Кода набора тестов
Параметры:
pTestSet - код группы тестов
Возвращаемое значение:
Код Отдела, в который входит тест</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	/*
	Set obj=##class(User.CTTestSet).%OpenId(pTestSet,0)
	If '$IsObject(obj) Quit ""
	Set result=""
	If ($IsObject(obj))&&($IsObject(obj.CTTSDepartmentDR)) {
		Set result=obj.CTTSDepartmentDR.%Id()
	}
	Quit result
	*/
	quit ..GetDepartmentByTestSet(pTestSet)
]]></Implementation>
</Method>

<Method name="GetDepartmentByTestSet">
<Description>
Вернуть код отдела для набора тестов
Параметры:
pTestSetCode - код набра тестов
Возвращаемое значение:
Код отдела</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetCode:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set department=""
	&Sql(
		Select %NOLOCK 
		CTTS_Department_DR
		Into :department
		From SQLUser.CT_TestSet 
		WHERE CTTS_Code=:pTestSetCode
	)
	If (SQLCODE'=0) Quit ""
	Quit department
]]></Implementation>
</Method>

<Method name="DefaultSpecimen">
<Description>
Биоматериал по умолчанию для набора тестов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set testsetobj=##class(User.CTTestSet).%OpenId(pTestSet,0)
	If '$IsObject(testsetobj) Quit ""
	Set result="",key=""
	For  {
		Set specimenobj=testsetobj.ChildCTTestSetSpecimen.GetNext(.key)
		If key="" Quit
		If $IsObject(specimenobj)&&($IsObject(specimenobj.CTTSSSpecimenDR)) {
			Set result=specimenobj.CTTSSSpecimenDR.%Id()
		}
		If result'="" Quit	 
	}
	if result="" {
		Set key=""   
	    For  {
		     Set containerobj=testsetobj.ChildCTTestSetContainers.GetNext(.key)
		     If key="" Quit
		     If $IsObject(containerobj)&&($IsObject(containerobj.CTTSYSpecimenDR)) {
			    Set result=containerobj.CTTSYSpecimenDR.%Id()
		     }
		     If result'="" Quit	 
	    }
	}
	/* еще надо сделать по кодам тестов	
		if result="" {
		   &SQL(SELECT CTSPE_Code INTO :result
	          FROM ((CT_Specimen INNER JOIN 
		      (CT_TestCode INNER JOIN CT_TestCodeContainers ON CT_TestCode.CTTC_RowId = CT_TestCodeContainers.CTTCB_ParRef) ON CT_Specimen.CTSPE_RowId = CT_TestCodeContainers.CTTCB_Specimen_DR) 
		      INNER JOIN CT_TestSetFields ON CT_TestCode.CTTC_RowId = CT_TestSetFields.CTTSF_DataItem_DR) 
		      INNER JOIN CT_TestSet ON CT_TestSetFields.CTTSF_ParRef = CT_TestSet.CTTS_RowId 
		      WHERE CTTS_Code=:pTestSet)
		}
	}*/
	
	Quit result
]]></Implementation>
</Method>

<Method name="NeedRemoveFromGroupPrinting">
<Description>
Нужно ли удаление набора тестов pTestSetId из групповой печати</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<Implementation><![CDATA[
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId,0)
	If ('$IsObject(testsetobj)) Quit 0
	Set testsetcode=testsetobj.VISTSTestSetDRGetObjectId()
	If testsetcode="" Quit 0
	Set cttestsetobj=##class(User.CTTestSet).%OpenId(testsetcode,0)
	If '$IsObject(cttestsetobj) Quit 0
	If cttestsetobj.CTTSExcludeFromFullFinal="Y" Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="RemoveFromGroupPrinting">
<Description>
Удаление наборов тестов pTestSetId из групповой печати</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<Implementation><![CDATA[
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId,0)
	If '$IsObject(testsetobj) Quit
	Set episobj=testsetobj.VISTSParRef
	If '$IsObject(episobj) Quit
	Set hospobj=testsetobj.VISTSParRef.EPVISHospitalCodeDR
	If '$IsObject(hospobj) Quit 
	Set courierobj=hospobj.CTHOSCourierRunDR
	If '$IsObject(courierobj) Quit 
	Set courierid=courierobj.%Id()
	Set hospitalid=hospobj.%Id()
	Set episid=episobj.%Id()
	Set testset=$Piece(pTestSetId,"||",2)
	Set testsetnum=$Piece(pTestSetId,"||",3)
	If (courierid="")||(hospitalid="")||(episid="")||(testset="")||(testsetnum="") Quit
	Kill ^TRPT("DR",courierid,"H",hospitalid,episid,testset,testsetnum)
]]></Implementation>
</Method>

<Method name="IsCito">
<Description>
Равен ли приоритет набора тестов "U" (Cito)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit 0
	If '$IsObject(testsetobj.VISTSPriorityDR) Quit 0
	If testsetobj.VISTSPriorityDR.%Id()="U" Quit 1
 	Quit 0
]]></Implementation>
</Method>

<Method name="IsCito2">
<Description>
Равен ли приоритет набора тестов "U" (Cito)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	if $get(pTestSetId)="" quit 0
	set epis=$piece(pTestSetId,"||",1)
	set testset=$piece(pTestSetId,"||",2)
	set tscnt=$piece(pTestSetId,"||",3)
	if (epis="")||(testset="")||(tscnt="") quit 0
	set rec=$get(^TEPI(epis,1,testset,tscnt))
	if rec="" quit 0
	set priority=$piece(rec,"\",10)
	if priority="" quit 0
	if (priority'="")&&($$seldata^LVBCTPR(priority,4)="Y") quit 1
 	Quit 0
]]></Implementation>
</Method>

<Method name="GetSectionByTestSet">
<Description>
Вернуть код отдела для набора тестов
Параметры:
pTestSetCode - код набра тестов
Возвращаемое значение:
Код отдела</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetCode:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set section=""
	&Sql(
		Select %NOLOCK 
		CTTS_Section_DR
		Into :section
		From SQLUser.CT_TestSet 
		WHERE CTTS_Code=:pTestSetCode
	)
	If (SQLCODE'=0) Quit ""
	Quit section
]]></Implementation>
</Method>

<Method name="GetPropertyPosition">
<Description>
Вернуть позицию свойства в списке формата $LB() значений набора тестов 
Параметры:
pProperty - Свойство
Возвращаемое значение:
Позиция в списке</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pProperty:%String</FormalSpec>
<ReturnType>%Integer</ReturnType>
<Implementation><![CDATA[
	Quit $Case(pProperty,
              "%ID":1,
              "VISTSTestSetDR":2,
              "VISTSSuperSetDR":3,
              "VISTSPriorityDR":4,
              "VISTSStatusResult":5,
              "VISTSDateOfAuthorisation":6,
              "VISTSTimeOfAuthorisation":7,
              "VISTSUserAuthorisedDR":8,
              "VISTSReasonDR":9,
              "VISTSDateOfReason":10,
              "VISTSTimeOfReason":11,
              "VISTS_UserReason_DR":12,
              :"")
]]></Implementation>
</Method>

<Method name="GetPropertyValue">
<Description>
Вернуть значение заданного свойства в списке формата $LB() значений набора тестов 
Параметры:
pValues - Список значений
pProperty - Свойство
Возвращаемое значение:
Значение свойства в списке</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValues:%String,pProperty:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set result=""
	Try {
		Set pos=..GetPropertyPosition(pProperty)
		If pos'="" {
			Set result=$ListGet(pValues,pos)
		}	
	}Catch {
	}
	Quit result
]]></Implementation>
</Method>

<Method name="WasAuthorization">
<Description>
Была ли авторизация набора тестов при вызове триггера для эпизода pEpisode, Id набора тестов  pTestSetId, новых значений pValues, старых значений pOldValues</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	If (pEpisode="")||(pTestSetId="") Quit 0
	;
	Set dateofauthorisation=$Get(pValues(7))
	Set authoriseduser=$Get(pValues(9)) 
	If (dateofauthorisation="")||(authoriseduser="") Quit 0			// Дата авторизации и авторизовавший пользователь должны быть заполнены

	Set olddateofauthorisation=$Get(pOldValues(7))
	Set oldauthoriseduser=$Get(pOldValues(9)) 
	If (olddateofauthorisation="")&&(oldauthoriseduser="") Quit 1	// а старой даты авторизации и авторизовавшего пользователя не должно быть
	Quit 0
	;
]]></Implementation>
</Method>

<Method name="WasDeauthorization">
<Description>
Была ли анулирование авторизации набора тестов при вызове триггера для эпизода pEpisode, Id набора тестов  pTestSetId, новых значений pValues, старых значений pOldValues</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	If (pEpisode="")||(pTestSetId="") Quit 0
	;
	Set status=$Get(pValues(33))
	Set oldstatus=$Get(pOldValues(33))
	Set result=0
	If (status="E")&&((oldstatus="A")||(oldstatus="")) { 							// Была деавторизация набора тестов (иногда старый значение становится пусто, а не "А")
		Set result=1
	}	
	Quit result
]]></Implementation>
</Method>

<Method name="WasCancellation">
<Description>
Была ли отмена  набора тестов при вызове триггера для эпизода pEpisode, Id набора тестов  pTestSetId, новых значений pValues, старых значений pOldValues
Для EMC не являются настоящей причиной отмены причины с CTRBillable="Y" (например, 	Дозаказ и Материал ожидается, т.е. это как бы откладывание набора тестов)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pEpisode:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	If (pEpisode="")||(pTestSetId="") Quit 0
	;
	Set reason=$Get(pValues(58))
	Set notreason=0
	Set reasonobj=##class(User.CTReason).%OpenId(reason,0)
	If ($IsObject(reasonobj))&&(reasonobj.CTRBillable="Y") {
		Set notreason=1
	}	
	If (reason="")||(notreason)  Quit 0								// Новая причина должна быть и у этой причины отмены не должно быть CTRBillable="Y"
	//
	Set oldreason=$Get(pOldValues(58))							 
	Set notreason=0
	Set reasonobj=##class(User.CTReason).%OpenId(oldreason,0)
	If ($IsObject(reasonobj))&&(reasonobj.CTRBillable="Y") {
		Set notreason=1
	}
	If (oldreason="")||(notreason)  Quit 1							// а также старой причины отмены не должно быть или у нее было CTRBillable="Y"
	Quit 0
]]></Implementation>
</Method>

<Method name="LogEvent">
<Description>
Сохранить событие об изменении набора тестов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pRecordUpdateType:%String,pEpisId:%String,pTestSetId:%String,&pValues:%String,&pOldValues:%String]]></FormalSpec>
<Implementation><![CDATA[
	Try
	{
	If ($Get(pRecordUpdateType)="")||($Get(pEpisId)="")||($Get(pTestSetId)="") Quit
	Set (event,extra1,extra2,extra3)=""
	Set user=##class(TCLEx.Data.Event).CurrentUser()
	//
	If pRecordUpdateType="Insert" {
		Set event="TESTSET_ADD"
		If $Get(pValues(39))'="" {		//VISTS_UserCreated_DR
			Set extra1="Manual"
		}Else {
			Set (extra1,user)="WebER"
		}	
	}ElseIf pRecordUpdateType="Delete" {
		Set event="TESTSET_DEL"
	}Else {
		If ##class(TCLEx.Function.TestSet).WasAuthorization(pEpisId,pTestSetId,.pValues,.pOldValues) {
			Set event="TESTSET_AUTH"
		}ElseIf ##class(TCLEx.Function.TestSet).WasDeauthorization(pEpisId,pTestSetId,.pValues,.pOldValues) {
			Set event="TESTSET_AUTH_CANCEL"
		}ElseIf ##class(TCLEx.Function.TestSet).WasCancellation(pEpisId,pTestSetId,.pValues,.pOldValues) {
			Set event="TESTSET_CANCEL"
			Set extra3=$Get(pValues(58))  // VISTS_Reason_DR
		}		
	}
	If event="" Quit
	
	Set ordernumber=##class(TCLEx.Function.LabOrder).GetOrderByEpisode(pEpisId)
	Set ordernumberid=##class(WebER.Data.LabOrder).GetIdByNumber(ordernumber)
	If ordernumberid="" {
		Set ordernumber=""
	}	
	Set hospital=""
	Set episodeobj=##class(User.EPVisitNumber).%OpenId(pEpisId,0)
	If $IsObject(episodeobj) {
		Set hospital=episodeobj.EPVISHospitalCodeDRGetObjectId()
	}	
	Set extra2=$Get(pValues(3))
	Do ##class(TCLEx.Data.Event).Save(event,ordernumber,pEpisId,pTestSetId,,"User.EPVisitTestSet",pTestSetId,hospital,user,,extra1,extra2,extra3)
	If (event="TESTSET_AUTH")||(event="TESTSET_CANCEL")||(event="TESTSET_DEL") {
		If ##class(TCLEx.Function.Episode).IsComplete(pEpisId) {
			Do ##class(TCLEx.Data.Event).Save("EPISODE_COMPLETE",ordernumber,pEpisId,,,"User.EPVisitNumber",pEpisId,hospital,user)
		}	
	}
	}
	catch {
	}
]]></Implementation>
</Method>

<Method name="IsAuthorisedLB">
<Description>
Является ли набор тестов со значениями передаваемыми в списке формата $ListBuild авторизованным
Параметры:
pValues - Значения в формате $ListBuild
Возвращаемое значение:
1 - Авторизован
0 - Нет</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValues:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set status=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSStatusResult")
	Set authdate=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSDateOfAuthorisation")
	Set authtime=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSTimeOfAuthorisation")
	Set authuser=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSUserAuthorisedDR")
	Quit ..IsAuthorisedVals(status,authdate,authtime,authuser)
]]></Implementation>
</Method>

<Method name="IsAuthorisedVals">
<Description>
Является ли набор тестов со следующими значениями авторизованным
Параметры:
pStatus - Статус набора тестов
pDateOfAuthorisation - дата авторизации
pTimeOfAuthorisation - время авторизации
pAuthorisedUser - авторизовавший пользователь
Возвращаемое значение:
1 - Авторизован
0 - Нет</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pStatus:%String,pDateOfAuthorisation:%String,pTimeOfAuthorisation:%String,pAuthorisedUser:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If pStatus'="A" Quit 0
	If (pDateOfAuthorisation="")||(pTimeOfAuthorisation="")||(pAuthorisedUser="") Quit 0
	Quit 1
]]></Implementation>
</Method>

<Method name="IsCanceledLB">
<Description>
Является ли набор тестов со значениями передаваемыми в списке формата $ListBuild отмененным c печатаемой причиной отмены
Параметры:
pValues - Значения в формате $ListBuild
Возвращаемое значение:
1 - Отменен
0 - Нет</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValues:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set reason=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSReasonDR")
	Set reasondate=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSDateOfReason")
	Set reasontime=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSTimeOfReason")
	Quit ..IsCanceledVals(reason,reasondate,reasontime)
]]></Implementation>
</Method>

<Method name="IsCanceledVals">
<Description>
Отменен ли Набор тестов User.EPVisitTestSet с печатаемой причиной отмены  (reasonobj.CTRReportable="Y")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pReason:%String,pReasonDate:%String,pReasonTime:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If (pReason="")||(pReasonDate="")||(pReasonTime="") Quit 0
	Set reasonobj=##class(User.CTReason).%OpenId(pReason,0)
	If '$IsObject(reasonobj) Quit 0
	If reasonobj.CTRReportable="Y" Quit 1
	Quit 0
]]></Implementation>
</Method>

<Method name="IsCanceledLB2">
<Description>
Является ли набор тестов со значениями передаваемыми в списке формата $ListBuild отмененным c любой причиной отмены
Параметры:
pValues - Значения в формате $ListBuild
Возвращаемое значение:
1 - Отменен
0 - Нет</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValues:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set reason=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSReasonDR")
	Set reasondate=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSDateOfReason")
	Set reasontime=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSTimeOfReason")
	Quit ..IsCanceledVals2(reason,reasondate,reasontime)
]]></Implementation>
</Method>

<Method name="IsCanceledVals2">
<Description>
Отменен ли Набор тестов User.EPVisitTestSet с печатаемой причиной отмены  (reasonobj.CTRReportable="Y")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pReason:%String,pReasonDate:%String,pReasonTime:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	If (pReason="")||(pReasonDate="")||(pReasonTime="") Quit 0
	Quit 1
]]></Implementation>
</Method>

<Method name="IsPrintableLB">
<Description>
Является ли набор тестов со значениями передаваемыми в списке формата $ListBuild печатаемым
Параметры:
pValues - Значения в формате $ListBuild
Возвращаемое значение:
1 - Печатаемый
0 - Непечатаемый</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pValues:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	
	Set testsetid=$listGet(pValues,1) 			; SQLUser.EP_VisitTestSet\VISTS_RowId
	quit $$printable^LVBCTTS($piece(testsetid,"||",2),testsetid,"Y")
	
	/*
	If ..IsAuthorisedLB(pValues) Quit 1
	If ..IsCanceledLB(pValues) {
		//Set reason=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"VISTSReasonDR")
		//If ##class(TCLEx.Function.CodeTable).IsReportableReason(reason)
		Quit 1
	}	
	Set testsetid=##class(TCLEx.Function.TestSet).GetPropertyValue(pValues,"%ID")
	Quit ..IsInPrintableVerificationQueue(testsetid)
	*/
]]></Implementation>
</Method>

<Method name="IsTestSetWord">
<Description>
Обрабатывается ли набор тестов с помощью word </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	if $get(pTestSet)="" quit 0
    quit $select($$seldata^LVBCTTS(pTestSet,54)="Y":1,1:0)
]]></Implementation>
</Method>

<Method name="IsTestSetWordToPDF">
<Description>
Обрабатывается ли набор тестов с помощью word и при этом word результаты переводятся в PDF</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[    quit $select((..IsTestSetWord(pTestSet))&&(+$get(^Settings("WordToPdf","stop"))=0):1,1:0)
]]></Implementation>
</Method>

<Method name="GetDoctorAuthorisation">
<Description>
Получить код врача, авторизовавшего набор тестов в эпизоде</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set doctorId=""
	&Sql(
		Select %NOLOCK 
		VISTS_UserAuthorised_DR
		Into :doctorId
		From SQLUser.EP_VisitTestSet 
		WHERE VISTS_RowId=:pTestSetId
	)
	If (SQLCODE'=0) Quit ""
	Quit doctorId
]]></Implementation>
</Method>

<Method name="GetDoctorAuthorisationDefault">
<Description>
Получить код врача, авторизовавшего набор тестов в эпизоде
Если пользователь, авторизовавший резкльтаты, = trak, то взять врача по умолчанию для отдела</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pDoctorId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $get(pDoctorId)="" {
		Set doctorId=##class(TCLEx.Function.TestSet).GetDoctorAuthorisation(pTestSetId)
	} else {
		set doctorId=pDoctorId
	}
	// Автоматическое подтверждение - тогда берем доктора по умолчанию для отдела
	if doctorId="trak" {
		set dep=$piece($piece(pTestSetId,"||",2),1)
		if dep'="" {
			set doctorDefault=$piece($get(^TTAB("DEP",dep)),"\",8)
			if doctorDefault'="" set doctorId=doctorDefault
		}
	}
	Quit doctorId
]]></Implementation>
</Method>

<Method name="IsTime4Result">
<Description>
Наступило ли время для формирования результата для указанного набора тестов
Параметры:
pTestSetId - ID набора тестов
pAuthDateTime - время авторизации набора тестов
Возвращаемое значение:
0 - рано формировать	
1 - пора формировать	</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String,pAuthDateTime:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set result=1
	Set episid=$Piece(pTestSetId,"||",1)
	// Время авторизации первого набора тестов в эпизоде
	Set firstauthdatetime=##class(TCLEx.Function.Episode).FirstAuthorizationDateTime(episid)
	If firstauthdatetime="" {		// Если его нет, то берем время аворизации текущего набора тестов (перестраховка, такого быть не должно)
		Set firstauthdatetime=pAuthDateTime
	}
	Set episobj=##class(User.EPVisitNumber).%OpenId(episid)
	If '$IsObject(episobj) Quit 0
	Set priority=episobj.EPVISPriorityCodeDRGetObjectId()
	Set testsetobj=##class(User.EPVisitTestSet).%OpenId(pTestSetId)
	If '$IsObject(testsetobj) Quit 0
	If '##class(TCLEx.Function.Laboratory).IsCitoPriority(priority) {
		Set priority=episobj.EPVISPriorityCodeDRGetObjectId()
	}
	Set testset=testsetobj.VISTSTestSetDRGetObjectId()
	Quit ..IsTime4Result2(testset,priority,firstauthdatetime,pAuthDateTime)
]]></Implementation>
</Method>

<Method name="IsTime4Result2">
<Description>
Наступило ли время для формирования результата для указанного набора тестов
Параметры:
pTestSet - код набора тестов
pPriority - код приоритета
pMinAuthDateTime - минимальное время авторизации
pAuthDateTime - время авторизации набора тестов
Возвращаемое значение:
0 - рано формировать	
1 - пора формировать	</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSet:%String,pPriority:%String,pMinAuthDateTime:%String,pAuthDateTime:%String</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	Set result=1
	Do ..TestSetTimeOuts(pTestSet,pPriority,.firsttimeout,.lasttimeout) 	// Тайм-ауты для эпизода с учетом срочности набора тестов
	//
	Set now=$Horolog
	Set deltatime=$$DeltaTimeSec^KSUTIL1(pMinAuthDateTime,now)	// Сравниваем разницу с момента авторизации первого набора тестов 
	If deltatime<firsttimeout {
		Set result=0
	} Else {
		Set deltatime=$$DeltaTimeSec^KSUTIL1(pAuthDateTime,now)	// Сравниваем разницу с момента авторизации текщего набора тестов
		If deltatime<lasttimeout {
			Set result=0
		}
	}		  										
	Quit result
]]></Implementation>
</Method>

<Method name="TestSetTimeOuts">
<Description>
Тайм-ауты для выгрузки набора тестов pTestSetId
pFirstTimeOut - время с момента авторизации первого набора тестов
pLastTimeOut - время с момента авторизации последнего набора тестов
Для Cito приоритетов (могут быть разные коды для разных лабораторий) берутся меньшие тайм-ауты
Также есть понятия: 
1) CitoTestSets - т.е. наборов тестов, которые всегда идут с тайм-аутами, как для Cito..
2) SuperCitoTestSets - т.е. наборов тестов, которые имеют тайм-ауты SuperCito, если приоритет исследования "U" (Cito) и "C" (Срочный) </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pTestSet:%String,pPriority:%String,&pFirstTimeOut:%Integer,&pLastTimeOut:%Integer]]></FormalSpec>
<Implementation><![CDATA[
	Set pPriority=$Get(pPriority)
	Set iscito=##class(TCLEx.Function.Laboratory).IsCitoPriority(pPriority)
	If ('iscito){
		Set citotestsets=$$CitoTestSets^Settings.Reports()
		If (citotestsets'="")&&(pTestSet'="")&&(citotestsets[(","_pTestSet_",")) {
			Set iscito=1
		}	
	}	
	If iscito {																			// Для CITO
		Set supercitotestsets=$$SuperCitoTestSets^Settings.Reports()
		If (supercitotestsets'="")&&(pTestSet'="")&&(supercitotestsets[(","_pTestSet_",")) {
			Set pFirstTimeOut=$$SuperCitoFirstTestSetTimeOut^Settings.Reports() 					// Сколько ждем с момента  первой авторизации TestSet-а эпизода или последней выгрузки результатов по эпизоду 
			Set pLastTimeOut=$$SuperCitoLastTestSetTimeOut^Settings.Reports()						// Сколько ждем с момента после авторизации TestSet-а						
		} Else {	
			Set pFirstTimeOut=$$CitoFirstTestSetTimeOut^Settings.Reports() 					// Сколько ждем с момента  первой авторизации TestSet-а эпизода или последней выгрузки результатов по эпизоду 
			Set pLastTimeOut=$$CitoLastTestSetTimeOut^Settings.Reports()						// Сколько ждем с момента после авторизации TestSet-а						
		}
	}Else {
		Set pFirstTimeOut=$$FirstTestSetTimeOut^Settings.Reports()
		Set pLastTimeOut=$$LastTestSetTimeOut^Settings.Reports()
	}
]]></Implementation>
</Method>

<Method name="GetCancelInfo">
<Description>
Получить данные об отмене набора тестов
output : $listbuild(код причины отмены, дата отмены, время отмены, доктор (пользователь), отменивший набор тестов, наименование причины отмены)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pTestSetId:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set reasoncode="",reasonname="",dateCancel="",timeCancel="",userCancel=""
	&Sql(
		Select %NOLOCK 
		VISTS_Reason_DR, VISTS_Reason_DR->CTR_Description,VISTS_DateOfReason, VISTS_TimeOfReason, VISTS_UserReason_DR 
		Into :reason,:reasonname,:dateCancel,:timeCancel,:userCancel
		From SQLUser.EP_VisitTestSet 
		WHERE VISTS_RowId=:pTestSetId
	)
	If (SQLCODE'=0) Quit ""
	Quit $listbuild(reason,dateCancel,timeCancel,userCancel,reasonname)
]]></Implementation>
</Method>
</Class>
</Export>
