<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="24">
<Class name="TCLEx.BI.BuildIndices">
<Super>%RegisteredObject</Super>
<TimeCreated>62880,70341.112081</TimeCreated>

<Method name="UpdateCubes">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		
		// создаем буфер эпизодов, по которым будем пересчитывать все кубы
		//(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)
		set ok=..CreateBufferEpisodes($na(^||bufRecountEpis))
		if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:CreateBufferEpisodes")
		}
 
        if '$data(^||bufRecountEpis) quit
        
        // Пересчитываем кубы
        set ok=..RebuildCubes($na(^||bufRecountEpis))
        if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:RebuildCubes")
		}
    } catch(exception) {
	       set ok=exception.AsStatus()
	       do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:UpdateCubes")  
    }   
  quit ok
]]></Implementation>
</Method>

<Method name="CreateBufferEpisodes">
<Description>
создаем буфер эпизодов, по которым будем пересчитывать кубы
(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuffer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		if $get(pBuffer)="" set pBuffer=$name(^||bufRecountEpis)
		kill @pBuffer
		
		set cubeepis="lab.EPVisitNumber"
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		
		// идем по ^SpeedI.DeltaP(cubeepis)
		set epis=""
        for {
	        set epis=$order(^SpeedI.DeltaP(cubeepis,epis)) if epis="" quit
	        set @pBuffer@(epis)=""
        }
        // идем по ^SpeedI.DeltaP(cubetestset)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestset,id)) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        if '$data(@pBuffer@(epis)) set @pBuffer@(epis)=""
        }
        // идем по ^SpeedI.DeltaP(cubetestsetdata)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestsetdata,id)) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        if '$data(@pBuffer@(epis)) set @pBuffer@(epis)=""
        }
        // идем по ^SpeedI.DeltaP(cubetestsetqueue)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestsetqueue,id)) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        if '$data(@pBuffer@(epis)) set @pBuffer@(epis)=""
        }
        
        // идем по ^SpeedI.DeltaP("TCLEx.Data.EPVisitNumberExt")
        // все изменения. которые делаются в классах BiRLab, взводят флаги в ^SpeedI.DeltaP("TCLEx.Data.EPVisitNumberExt")
        set class="TCLEx.Data.EPVisitNumberExt"
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(class,id)) if id="" quit
	        set epis=id
	        set flagRecalcPrice=$select($get(^SpeedI.DeltaP(class,id,"flagRecalcPrice"))=1:1,1:0)
	        if '$data(@pBuffer@(epis)) set @pBuffer@(epis)=flagRecalcPrice
        }
	} catch(e) { set ok=e.AsStatus() }
	quit ok
]]></Implementation>
</Method>

<Method name="RebuildCubes">
<Description>
// Пересчет кубов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuffer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok1=$$$OK,iserrors=0
	try {
		set cubeepis="lab.EPVisitNumber"
		set cubeepisBI=$piece(cubeepis,".",2) //"TCBI.Cubes.EPVisitNumber"
		
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetBI=$piece(cubetestset,".",2) //"TCBI.Cubes.EPVisitTestSet"
		
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetdataBI=$piece(cubetestsetdata,".",2) //"TCBI.Cubes.EPVisitTestSetData"
		
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		set cubetestsetqueueBI=$piece(cubetestsetqueue,".",2) //"TCBI.Cubes.EPVisitTestSetQueue"

		set epis=""
        for {
	        set epis=$order(@pBuffer@(epis),1,flagRecalcPrice) if epis="" quit
	        if flagRecalcPrice="" set flagRecalcPrice=0
	        /*
	        // пересчитываем сначала цены, код плательщика и т д, если надо
	        set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExt(epis,flagRecalcPrice)
	        if 'ok {
		        set iserrors=1
		        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:CreateEPVisitTestSetExt: episode="_$get(epis))
	        }*/
	        
	        // EPVisitNumber
	        set vals=$get(^SpeedI.DeltaP(cubeepis,epis))
	        if vals="" set vals=1
	        set ok=0
	        if vals=1 {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubeepisBI,epis)
		    }
		    if vals=0  {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubeepisBI,epis)
		    } 
		    if ok {
			    kill ^SpeedI.DeltaP(cubeepis,epis)
		    } 
		    else  {
			    set iserrors=1
			    do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubeepisBI)_", episode="_$get(epis))
		    }
	        
	        if 'ok continue
	        
	        // EPVisitTestSet удаление
	        set id=epis
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestset,id),1,vals) if (id="")||($piece(id,"||",1)'=epis) quit
		        if vals'=0 continue
		        set ok=0
		        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetBI,id)
		        if ok {
			        kill ^SpeedI.DeltaP(cubetestset,id)
		        }
		        else  {
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Delete cube "_$get(cubetestsetBI)_", id="_$get(id))
		        }
            }
	        
	        // EPVisitTestSet (пересчет куба для всех наборов тестов в данном эпизоде
	        set ts=""
	        for {
		        set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
		        set tscnt=""
		        for {
			        set tscnt=$order(^TEPI(epis,1,ts,tscnt)) if tscnt="" quit
			        set id=epis_"||"_ts_"||"_tscnt
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetBI,id)
			        if ok {
				        kill ^SpeedI.DeltaP(cubetestset,id) 
			        }
		            else  {
			            set iserrors=1
			            do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetBI)_", id="_$get(id))
		            }
		        }
	        }
	        
	        // EPVisitTestSetQueue 
	        set id=epis
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestsetqueue,id),1,vals) if (id="")||($piece(id,"||",1)'=epis) quit
		        
		        set ok=0
		        if vals=1 {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetqueueBI,id)
		        } 
		        elseif vals=0 {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetqueueBI,id)
			    }    
		        if ok {
			        kill ^SpeedI.DeltaP(cubetestsetqueue,id)
		        }
		        else  {
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetqueueBI)_", id="_$get(id))
		        }
            }
	        
	        // EPVisitTestSetData 
	        set id=epis
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestsetdata,id),1,vals) if (id="")||($piece(id,"||",1)'=epis) quit
		        
		        set ok=0
		        if vals=1 {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetdataBI,id)
		        } 
		        elseif vals=0 {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetdataBI,id)
			    }    
		        if ok {
			        kill ^SpeedI.DeltaP(cubetestsetdata,id)
		        }
		        else  {
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetdataBI)_", id="_$get(id))
		        }
            }
		    
        }
	} catch(e) { set ok1=e.AsStatus() }
	if (iserrors=1)&&(ok1=1) {
		set ok1=$$$ERROR($$$GeneralError,"Били ошибки при пересчете кубов. См. ^ERRORS")
	}
	quit ok1
]]></Implementation>
</Method>

<Method name="UpdateCubes3">
<Description>
для тестовых целей</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		set cubeepis="lab.EPVisitNumber"
		set cubeepisBI=$piece(cubeepis,".",2) //"TCBI.Cubes.EPVisitNumber"
		
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetBI=$piece(cubetestset,".",2) //"TCBI.Cubes.EPVisitTestSet"
		
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetdataBI=$piece(cubetestsetdata,".",2) //"TCBI.Cubes.EPVisitTestSetData"
		
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		set cubetestsetqueueBI=$piece(cubetestsetqueue,".",2) //"TCBI.Cubes.EPVisitTestSetQueue"
		
		// создаем буфер эпизодов, по которым будем пересчитывать все кубы
		//(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)
		kill ^||bufRecountEpis
		// идем по ^TEPI (последние 500 эпизодов)
		set epis="",count=0
        for {
	        set epis=$order(^TEPI(epis)) if epis=""||(count>500) quit
	        set ^||bufRecountEpis(epis)=""
	        set count=count+1
        }
        // Чистим кубы
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubeepisBI))
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubetestsetBI))
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubetestsetdataBI))
        
        // Пересчитываем кубы
        set ok=..RebuildCubes($na(^||bufRecountEpis))
        if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:RebuildCubes")
		}
    } catch(exception) {
	       set ok=exception.AsStatus()
    }   
  quit ok
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// только для тех наборов тестов, для которых цена ещене финальная

]]></Content>
</UDLText>

<Method name="CreateEPVisitTestSetExt">
<Description>
Заполнение класса TCLEx.Data.EPVisitNumberExt - не в первый раз 
Пока только про цену все придумано
pFlagRecalcFinalPrice - флаг : если=1, то пересчитывать Все цены (любой flagFinalPrice)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String,pFlagRecalcFinalPrice:%Boolean=0,pDateStartBirlab:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=1
	set pEpisode=$get(pEpisode)
	   
	try {
		if pEpisode="" {
			set ok =$$$ERROR($$$GeneralError,"Не указан номер эпизода")
			quit
		}
		set epis=pEpisode
		// эпизод уже закрыт целиком для пересчета цены
	    if (pFlagRecalcFinalPrice=0)&&($lg($get(^TEPIext(epis)),1)=1) quit
	    
	    // дата, когда был запущен Birlab
	    if pDateStartBirlab="" {
		    set pDateStartBirlab=##class(BiRLab.Function.Report).GetDateStartUseBirlab() 
	    }
	    
	    kill supersetPrice // локальный массив для супенаборов
	    
	    // открываем или создаем объект TCLEx.Data.EPVisitNumberExt
	    if ##class(TCLEx.Data.EPVisitNumberExt).%ExistsId(epis) {
	          set objepis=##class(TCLEx.Data.EPVisitNumberExt).%OpenId(epis)
        } else {
	          set objepis=##class(TCLEx.Data.EPVisitNumberExt).%New()
	          set objepis.Episode=epis
              set ok1=objepis.%Save()
              if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        }
	    
	    // удаление удаленных EPVisitTestSet
	    set ts=""
	    for {
	        set ts=$order(^TEPIext(epis,1,ts)) if ts="" quit
	        set tscnt=""
	        for {
		        set tscnt=$o(^TEPIext(epis,1,ts,tscnt)) if tscnt="" quit
		        if '$data(^TEPI(epis,1,ts,tscnt)) {
			        set rowid=epis_"||"_ts_"||"_tscnt
                    set ok1=##class(TCLEx.Data.EPVisitTestSetExt).%DeleteId(rowid)
                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		        }
	        }
	    }
	    	    
	    set rec=$get(^TEPI(epis))
	
		set hospitalcode=$piece(rec,"\",20)
		set dateOfEntry=$piece(rec,"\",8)
		        
        // код плательщика на уровне эпизода
        set flagGetPayerFromTestSet=1 // флаг о том, что надо смотреть код плательщика на уровне наборов тестов, если дата авторизации меньше даты начала использования Биралаба
	    set payment="" 
        set ok1=##class(TCLEx.Function.Episode2).GetPayer0(epis,.hospitalcode,.payment,.flagGetPayerFromTestSet)
        if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        
        set paymentCategory=##class(BiRLab.Function.InvoiceNew).GetPaymentCategory(payment) // сейчас все равно он всегда =1
        
 	    set hospitalPayerCategoryVersion="",pricelistversion=""
        
        set citoepis=$piece(rec,"\",15) // cito нужно только для расчета цены по встроенному в трек биллингу, а это было только в Бионе - поэтому cito берем только на уровне эпизода

	    set ts=""
	    set flagFinalEpis=1  // флаг о том, что для всех наборов тестов эпизоде цена уже берется из BiRLab.Data.InvoiceEpisodeItem или набор тестов отменен (в этих двух случаях этот флаг=1)
	    for {
	        set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
	        set tscnt=""
	        for {
		        set tscnt=$o(^TEPI(epis,1,ts,tscnt),1,rects) if tscnt="" quit
		        set status=$piece(rects,"\",31)
		        set reason=$piece(rects,"\",52) 
		        if (status'="A")&&(reason="") {
			        set flagFinalEpis=0
			        // если раньше была причина отмены или авторизация, то надо почистить доп данные
			        if $data(^TEPIext(epis,1,ts,tscnt)) {
				        set recext=^TEPIext(epis,1,ts,tscnt)
				        set price=+$lg(recext,1)
				        set flagFinalPrice=$lg(recext,2)
				        set flagIsService=$lg(recext,4)
				        if (price'=0)||(flagFinalPrice=1)||(flagIsService=1) {
					        set rowid=epis_"||"_ts_"||"_tscnt
				            set obj=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(rowid)
                            if $IsObject(obj) {
	                          set obj.Price=0
                              set obj.FlagFinalPrice=0
                              set obj.FlagIsService=0
                              do obj.%SetModified(1)
                              set ok1=obj.%Save()
                              if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1) 
                            }
				        }
			        }
			        continue
		        } 
		        
		        // Если не надо пересчитывать финальную цену, то не пересчитываем
		        if (pFlagRecalcFinalPrice=0)&&($lg($get(^TEPIext(epis,1,ts,tscnt)),2)=1) continue
		 		 
		        set authdate=$Piece(rects,"\",4)
		        Set superset=$p(rects,"\",29)
		        set dateOfreason=$piece(rects,"\",54)
	        
		        set citots=$Piece(rects,"\",10)
		        
		        set flagIsService=1 //флаг, что данная строка будет считаться как одна услуга (для супернабора на ней же лежит цена за супернабор )
		        // если набор тестов отменен по причине,для которой выставлен флаг "Все равно оплачивать" в данном контексте это все равно, что набор тесов не отменен
		        set flagCancel=0  // флаг, что данная строка считает отмененной совсем (услугой не является)
		        if (dateOfreason'="")&&(reason'="") {
			        if $piece($get(^TTAB("CTR",reason)),"\",3)'="Y" set flagCancel=1  
		        }
		        
  		        if (flagGetPayerFromTestSet=1)&&(((pDateStartBirlab'="")&&(authdate<pDateStartBirlab))) {
	                ; плательщик (на уровне набора тестов)
                    set paymentts=$p(rects,"\",23) 		;VISTS_PaymentCode_DR
                    if paymentts'="" set payment=paymentts
                }
		         
		        set price=""
		        set flagFinalPrice=0
		        
		        // если причина невыполения проставлена, то пишем цену 0 и проставляем флаг окончательности цены (если это не супернабор)
		        // в супернаборе часть наборов тестов может быть отменена, а часть сделана
		        if (flagCancel=1)&&(superset="") {    
		            set price=0  // в дальнейшем коде цена не пересчитывается в этом случае
		            set flagFinalPrice=1
		            set flagIsService=0
		        }
		        
		        // Если это неоплачиваемая услуга (VISTS_SupressBilling="Y"), то 
		        // для обычных наборов тестов : считаем кол-во услуг 1 и цена 0 и проставляем флаг финальной цены 
		        // для супернабора - если для "главного" набора тестов ISTS_SupressBilling="Y", то весь супернабор рассматривается как одна услуга с 0 ценой - например такой вариант жизни
		        set supressbilling=$piece(rects,"\",34)
		        
		        if (supressbilling="Y")&&(superset="") {  // неоплачиваемый набор тестов (но услуга считается услугой)
			        set price=0
			        set flagFinalPrice=1
			        set flagIsService=$select(authdate'="":1,1:0)
		        }
			       	        
		        set billingitem=ts
		        
                // обоработка супернабора
                if superset'="" {
	                Set billingitem=superset
	                set flagmaintestset=ts[superset // флаг, что это "главный" Набор тестов в супернаборе 
	                // если на какой-то набор тестов из супер набора уже записана цена за супернабор, то на другие наборы тестов записываем 0
	                If ($Data(supersetPrice(billingitem,tscnt)))||(flagmaintestset=0) {
		                set price=0
		                set flagFinalPrice=1  
		                set flagIsService=0
	                } else {
		                // если этот набор тестов отменен, то просто записываем в ^TEPIext цену 0 и флаг окончательности цены, но цену жля супернабора не записываем
		                set flagIsComplete=##class(TCLEx.Function.SuperSet).IsComplete(epis,superset) 
		                if (flagCancel=0)&&(flagIsComplete=1) {
			                set flagIsService=1
		                    set authdate=##class(TCLEx.Function.SuperSet).AuthorisationDate2(epis,superset)
		                    Set supersetPrice(billingitem,tscnt)="" 
		                    if supressbilling="Y" {
			                    set price=0
			                    set flagFinalPrice=1
		                    }
		                } else {
			                set price=0
			                set flagIsService=0
			                if flagIsComplete=1 set flagFinalPrice=1
		                }
	                }
                }
                set cito=$select(citots'="":citots,citoepis'="":citoepis,1:"")
                
	            // расчет цены по старому биллингу
                if ((pDateStartBirlab="")||(authdate<pDateStartBirlab)) {
	                //if '$data(^TEPIext(epis)) set $list(^TEPIext(epis),1)=1  // для этого эпизода не пересчитываем цены никогда (если в эпизоде хотя бы один набор тестов попал авторизован до появления Бирлаб, то считаем весь эпизод добирлабовским)
	                set flagFinalEpis=1
	                set flagFinalPrice=1
	                if price="" {
		                if (payment'="") 
		                {
			                Set price=$$GetBillingItemAmount^PRTCLNRUS05birlab(payment,epis,authdate,billingitem,cito,$name(^||invForGetPrice))
		                } else {
			                //set ok=$system.Status.AppendStatus(ok,$$$ERROR($$$GeneralError,"Не указан код плательщика для эпизода "_epis_" hospitacode="_$get(hospitalcode)))
			                //set ^test("fras","no_plat",epis,billingitem)=$get(hospitalcode)
			                set price=0
		                }
	                }
                }
                // расчет цены по новому биллингу
                else {
	                 if price="" {
		                    // смотрим цену окончательно закрепленную
		                    set ok1=##class(BiRLab.Function.InvoiceNew).GetFinalPrice(epis,billingitem,ts,tscnt,.cito,.flagFinalPrice,.price)
		                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		                    if (flagFinalPrice=0) {
			                    set ok1=##class(BiRLab.Function.InvoiceNew).GetPrice(payment, hospitalcode, paymentCategory, billingitem, dateOfEntry, cito, .pricelistversion, .hospitalPayerCategoryVersion,.price )
			                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		                    }
	                 }
                }
                if ($data(supersetPrice(billingitem,tscnt)))&&(flagIsService=1) {
	                Set supersetPrice(billingitem,tscnt)=flagFinalPrice
                }
                
                // запись в TCLEx.Data.EPVisitTestSetExt
                //set ^TEPIext(epis,1,ts,tscnt)=$listbuild(price,flagFinalPrice)
                set rowid=epis_"||"_ts_"||"_tscnt
                set obj=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(rowid)
                if '$IsObject(obj) {
	                set obj=##class(TCLEx.Data.EPVisitTestSetExt).%New()
	                set obj.Episode=objepis
	                do obj.TestSetSetObjectId(ts)
	                set obj.TestSetCounter=tscnt
                }
                set obj.Price=price
                set obj.FlagFinalPrice=flagFinalPrice
                set obj.SuperSet=superset
                set obj.FlagIsService=flagIsService
                do obj.%SetModified(1)
                set ok1=obj.%Save()
                if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
                
                if (flagFinalEpis=1)&&(flagFinalPrice=0) {
	                set flagFinalEpis=0
                } 
	        }
	        
        }
        
	    // запись в TCLEx.Data.EPVisitNumberExt and ^EPVisitNumber
        //set ^TEPIext(epis)=$listbuild(hospital,payment,flagFinalPrice)
        set recext=^TEPIext(epis)
        set hospitalold=$listget(recext,1),payerold=$listget(recext,2),flagFinalEpisOld=$listget(recext,3)
        if (hospitalcode'=hospitalold)||(payment'=payerold)||(flagFinalEpis'=flagFinalEpisOld) {
                set objepis.Payer=payment
                set objepis.FlagFinalPrice=flagFinalEpis
                do objepis.HospitalSetObjectId(hospitalcode)
                do objepis.%SetModified(1)
                set ok1=objepis.%Save()
                if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        }
        
        kill supersetPrice
        
	} catch(e) {
		set ok1=e.AsStatus()
		set ok=$system.Status.AppendStatus(ok,ok1)
	}
	if 'ok do ##class(TCLEx.Function.General).WriteError($ze,"TCLEx.BI.BuildIndices:CreateEPVisitTestSetExt:episode="_$get(epis))
	quit ok
]]></Implementation>
</Method>

<Method name="BIClassChange">
<Description>
Установить флаг изменения для пересчета данных в TCLEx.Data.EPVisitNumberExt (дополнительные данные по эпизоду)
Несоответсвующее название осталось исторически 
pClass - deprecated
pId - номер эпизода
pFlagDelete - deprecated
pInfo - флаг пересчета окончательной цены</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String="",pId:%String="",pFlagDelete:%Boolean="N",pInfo:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		/*
	    if (pClass'="")&&(pId'="") {
		    if pFlagDelete="Y" set ^SpeedI.DeltaP(pClass,pId)=0
	        else  set ^SpeedI.DeltaP(pClass,pId)=1
	    }
	    // дополнительная информация (например при удалении BiRLab.Data.InvoiceEpisodeItem в ней номер эпизода)
	    if pInfo'="" {
		    set ^SpeedI.DeltaP(pClass,pId,"info")=pInfo
	    }
	    */
	    set flagCalcFinalPrice=+pInfo // флаг обязательности пересчета цены (даже если установлен флаг финальной цены (цена взята из BiRLab.Data.InvoiceEpisodeItem))
	    set ok=##class(TCLEx.Task.ExtraCalcQueueManager).InsertInQueue(pId,flagCalcFinalPrice)
	    
	} catch(e) { set ok=e.AsStatus() }
	
	quit ok
]]></Implementation>
</Method>

<Method name="ExtraDataChange">
<Description>
Установить флаг изменения для пересчета данных в TCLEx.Data.EPVisitNumberExt (дополнительные данные по эпизоду)
pFlagCalcFinalPrice - флаг обязательности пересчета цены (даже если установлен флаг финальной цены (цена взята из BiRLab.Data.InvoiceEpisodeItem))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String="",pFlagCalcFinalPrice:%Boolean="N"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
	    set ok=##class(TCLEx.Task.ExtraCalcQueueManager).InsertInQueue(pEpisode,pFlagCalcFinalPrice)
	    
	} catch(e) { set ok=e.AsStatus() }
	
	quit ok
]]></Implementation>
</Method>

<Method name="InitialBuild">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ok=$$$OK
  try {
	// a complete rebuild of all cubes
	
	kill ^SpeedI.DeltaP
	
	set ts1=+$h*100000+$p($h,",",2)
	s ^test("buildcube","start")=$h
	//do CreateIndex^PRTCLNRUS05birlab($name(^invForGetPrice))
	set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExtFirst()
	b  //
	//d ##class(%DeepSee.Utils).%BuildCube("BBPPackDetails",0)
	d ##class(%DeepSee.Utils).%BuildCube("BBPPackTransactions",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitNumber",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSet",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetData",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetDataAntib",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetQueue",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetSnomedRes",0)
	set ts2=+$h*100000+$p($h,",",2)
	set ras=ts2-ts1
	set ^test("BuildCubes")=ras_" сек "_(ras\3600)_" ч"
	w !,ras_" сек "_(ras\3600)_" ч"
  } catch(e) { set ok=e.AsStatus() }
  q ok
]]></Implementation>
</Method>

<Method name="InitialCaclPrice">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ok=$$$OK
  try {
	
	kill ^SpeedI.DeltaPext
	
	set ts1=+$h*100000+$p($h,",",2)
	s ^test("calcprice","start")=$h
	//do CreateIndex^PRTCLNRUS05birlab($name(^invForGetPrice))
	set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExtFirst()
	set ts2=+$h*100000+$p($h,",",2)
	set ras=ts2-ts1
	set ^test("calcprice","stop")=$h_" ras="_ras_" сек "_(ras\3600)_" ч"
	w !,ras_" сек "_(ras\3600)_" ч"
  } catch(e) { set ok=e.AsStatus() }
  q ok
]]></Implementation>
</Method>

<Method name="CreateEPVisitTestSetExtFirst">
<Description>
Заполнение класса TCLEx.Data.EPVisitNumberExt - в первый раз (перед первым строительством кубов по уже имеющимся данным)
Пока только про цену все придумано</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=1
	try {
		// создание индекса для быстрого расчета цены по сарому биллингу
	    do CreateIndex^PRTCLNRUS05birlab($name(^||invForGetPrice))
	
	    kill ^TEPIext,^TEPIextI
	
	    set dateStartBirlab=##class(BiRLab.Function.Report).GetDateStartUseBirlab()
	    
	    set epis="" 
	    for {
		    set epis=$order(^TEPI(epis)) if epis="" quit
		    set ok1=..CreateEPVisitTestSetExt(epis,1,dateStartBirlab)
		    if 'ok1 {
			    write !,"episode="_epis
			    do $system.Status.DisplayError(ok1)
			    //set ok=$system.Status.AppendStatus(ok,ok1)
			    //quit
		    }
        }
        do ..SetFlagFinalPrice() // Для некоторых эпизодов насильственно в первый раз поставить флаг окончательности цены
	} catch(e) {
		
	}
	quit ok
]]></Implementation>
</Method>

<Method name="SetFlagFinalPrice">
<Description>
Для некоторых эпизодов насильственно в первый раз поставить флаг окончательности цены</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set datelimit=$extract($zd(+$h,8),1,6)-7
	set ok=1
	try {
		set counter=0
		set hospital=""
		for {
			set hospital=$order(^TEPIextI("FlagFinalPriceHospital",0,hospital)) if hospital="" quit
			set epis=""
		    for {
			   set epis=$order(^TEPIextI("FlagFinalPriceHospital",0,hospital,epis)) if epis="" quit
			   set dateOfEntry=$extract($zd($piece(^TEPI(epis),"\",8),8),1,6)
			   if dateOfEntry>datelimit continue
			   set objepis=##class(TCLEx.Data.EPVisitNumberExt).%OpenId(epis)
			   set objepis.FlagFinalPrice=1
			   do objepis.%SetModified(1)
			   set ok1=objepis.%Save()
			   if 'ok1  do $system.Status.DisplayError(ok1)
			   set counter=counter+1
			   set ts=""
			   for {
				   set ts=$order(^TEPIext(epis,1,ts)) if ts="" quit
				   set tscnt=""
				   for {
					   set tscnt=$order(^TEPIext(epis,1,ts,tscnt),1,rects) if tscnt="" quit
					   if $listget(rects,2)=1 continue
					   set objts=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(epis_"||"_ts_"||"_tscnt)
					   set objts.FlagFinalPrice=1
					   do objts.%SetModified(1)
					   set ok1=objts.%Save()
					   if 'ok1  do $system.Status.DisplayError(ok1)
				   }
			   }
		    }
		}
		write !,"Для эпизодов полугодовой давности насильственно проставлен флаг финальной цены: "_counter_" эпизодов",!
	} catch(e) {
		do $system.Status.DisplayError(e.AsStatus())
	}
	quit ok
]]></Implementation>
</Method>

<Method name="ForTest">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	do ##class(TCLEx.Task.ExtraCalcQueueManager).DoTask()
	set ok=..UpdateCubes()
]]></Implementation>
</Method>

<Method name="CalcForTest">
<Description>
метод не доделан</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCouter:%Integer=1000</FormalSpec>
<Implementation><![CDATA[
	do ##class(%DeepSee.Utils).%KillCube("EPVisitNumber")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSet")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitRestSetData")
	set count=0
	set epis=""
        for {
	        set epis=$order(^TEPI(epis)) if epis="" quit
	        set count=count+1
	        if count>pCouter quit
	        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitNumber",epis)
		    if 'ok {
			    do $system.Status.DisplayError(ok)
		    } 
	        
	        // EPVisitTestSet (пересчет куба для всех наборов тестов в данном эпизоде
	        set ts=""
	        for {
		        set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
		        set tscnt=""
		        for {
			        set tscnt=$order(^TEPI(epis,1,ts,tscnt)) if tscnt="" quit
			        set id=epis_"||"_ts_"||"_tscnt
			        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitTestSet",id)
			        if 'ok {
				        do $system.Status.DisplayError(ok)
			        }
			        set test=""
			        for {
				        set test=$order(^TEPI(epis,1,ts,tscnt,"DATA",test)) if test="" quit
				        set id=epis_"||"_ts_"||"_tscnt_"||"_test
				        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitTestSetData",id)
			            if 'ok {
				           do $system.Status.DisplayError(ok)
			            }
			        }
		        }
	        }

        }
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// end class

]]></Content>
</UDLText>
</Class>
</Export>
