<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="24">
<Class name="TCLEx.BI.BuildIndices">
<Description>
</Description>
<Super>%RegisteredObject</Super>
<TimeCreated>62880,70341.112081</TimeCreated>

<Parameter name="IntervalWriteEpisodeInDeepSee">
<Description>
Минимальный интервал в секундах между корректировкой эпизода и записью данных в DeepSee</Description>
<Default>30</Default>
</Parameter>

<Method name="UpdateCubes">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		
		// создаем буфер эпизодов, по которым будем пересчитывать все кубы
		//(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)
		kill ^||bufRecountEpis
		set ok=..CreateBufferEpisodes($na(^||bufRecountEpis))
		if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:CreateBufferEpisodes")
		}
          
        if '$data(^||bufRecountEpis) quit
         
        /*
        // Проверка связки набор тестов-образец
        set ok=..BindTestSetSpecimen()
        if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:BindTestSetSpecimen")
		}
		*/
		 
        // Пересчитываем кубы
        set ok=..RebuildCubes($na(^||bufRecountEpis))
        if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:RebuildCubes")
		}
    } catch(exception) {
	       set ok=exception.AsStatus()
	       do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:UpdateCubes")  
    }   
  quit ok
]]></Implementation>
</Method>

<Method name="CreateBufferEpisodes">
<Description>
создаем буфер эпизодов, по которым будем пересчитывать кубы
(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuffer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		if $get(pBuffer)="" set pBuffer=$name(^||bufRecountEpis)
		kill @pBuffer
		
		set cubeepis="lab.EPVisitNumber"
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		
		// идем по ^SpeedI.DeltaP(cubeepis)
		set epis=""
        for {
	        set epis=$order(^SpeedI.DeltaP(cubeepis,epis),1,rec) if epis="" quit
	        set horolog=$piece(rec,$char(0),2)
		    set @pBuffer@(epis)=horolog
        }
        // идем по ^SpeedI.DeltaP(cubetestset)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestset,id),1,rec) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        set horolog=$piece(rec,$char(0),2)
	        if horolog>$get(@pBuffer@(epis)) set @pBuffer@(epis)=horolog
        }
        // идем по ^SpeedI.DeltaP(cubetestsetdata)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestsetdata,id),1,rec) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        set horolog=$piece(rec,$char(0),2)
	        if horolog>$get(@pBuffer@(epis)) set @pBuffer@(epis)=horolog
        }
        /*
        // идем по ^SpeedI.DeltaP(cubetestsetqueue)
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(cubetestsetqueue,id),1,rec) if id="" quit
	        set epis=$piece(id,"||",1) if epis="" continue
	        set horolog=$piece(rec,$char(0),2)
	        if horolog>$get(@pBuffer@(epis)) set @pBuffer@(epis)=horolog
        }
        */
        
        // идем по ^SpeedI.DeltaP("TCLEx.Data.EPVisitNumberExt")
        // все изменения. которые делаются в классах BiRLab, взводят флаги в ^SpeedI.DeltaP("TCLEx.Data.EPVisitNumberExt")
        set class="TCLEx.Data.EPVisitNumberExt"
        set id=""
        for {
	        set id=$order(^SpeedI.DeltaP(class,id),1,rec) if id="" quit
	        set epis=id
	        set flagRecalcPrice=$select($get(^SpeedI.DeltaP(class,id,"flagRecalcPrice"))=1:1,1:0)
	        set horolog=$piece(rec,$char(0),2)
	        if '$data(@pBuffer@(epis)) {
			    set @pBuffer@(epis)=horolog_$char(0)_flagRecalcPrice
	        } else {
			    set rec=@pBuffer@(epis)
			    if horolog>$piece(rec,$char(0),1) set $piece(@pBuffer@(epis),$char(0),1)=horolog
			    set flagRecalcPriceOld=+$piece(rec,$char(0),2)
			    if (flagRecalcPrice=1)&&(flagRecalcPriceOld=0) set $piece(@pBuffer@(epis),$char(0),2)=flagRecalcPrice
		    }
        }
        
        // Идем по выбранным эпизодам и проверяем время (довольно ли давно были сделаны изменения в эпизоде)
		set curhorolog=$h
		set curdate=$piece(curhorolog,",",1),curtime=$piece(curhorolog,",",2)
        set ras=..#IntervalWriteEpisodeInDeepSee // пересчет только если прошло больше минуты после последнего обновления ^SpeedI.DeltaP
        set epis=""
        for {
	        set epis=$order(@pBuffer@(epis),1,rec) if epis="" quit
	        set horolog=$piece(@pBuffer@(epis),$char(0),1)
	        set date=$piece(horolog,".",1),time=$piece(horolog,".",2)
	        if (date<curdate)||((date=curdate)&&((curtime-time)>ras)) {
		        continue
	        }
	        kill @pBuffer@(epis)
        }
	} catch(e) { set ok=e.AsStatus() }
	quit ok
]]></Implementation>
</Method>

<Method name="RebuildCubes">
<Description>
// Пересчет кубов</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pBuffer:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok1=$$$OK,iserrors=0
	try {
		set r=$char(0)
		set cubeepis="lab.EPVisitNumber"
		set cubeepisBI=$piece(cubeepis,".",2) //"TCBI.Cubes.EPVisitNumber"
		
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetBI=$piece(cubetestset,".",2) //"TCBI.Cubes.EPVisitTestSet"
		
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetdataBI=$piece(cubetestsetdata,".",2) //"TCBI.Cubes.EPVisitTestSetData"
		
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		set cubetestsetqueueBI=$piece(cubetestsetqueue,".",2) //"TCBI.Cubes.EPVisitTestSetQueue"
		
		set cubeepisExt="TCLEx.Data.EPVisitNumberExt"

		set epis=""
        for {
	      set epis=$order(@pBuffer@(epis),1,rec) if epis="" quit
	      set maxtime=$piece(rec,r,1)
	        
	      TSTART
	      try {
	        set isquit=0  // флаг о том, что надо закончить расчет для данного эпизода
	        set flagRecalcPrice=$piece(rec,r,2)
	        if flagRecalcPrice="" set flagRecalcPrice=0
	        /*
	        // пересчитываем сначала цены, код плательщика и т д, если надо
	        set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExt(epis,flagRecalcPrice)
	        if 'ok {
		        set iserrors=1
		        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:CreateEPVisitTestSetExt: episode="_$get(epis))
	        }*/
	        
	        // EPVisitNumber
	        set vals=$get(^SpeedI.DeltaP(cubeepis,epis))
	        if vals="" set vals=$get(^SpeedI.DeltaP(cubeepisExt,epis))
	        
	        set timeLastChange=$piece(vals,r,2)
	        if ..IsChangeEpisode(epis,maxtime,timeLastChange,epis) { TROLLBACK  set isquit=1 quit }
	        set typechange=$piece(vals,r,1)
	        if typechange="" set typechange=1
	        set ok=1
	        if (typechange=1) {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubeepisBI,epis)
		    }
		    elseif typechange=0  {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubeepisBI,epis)
		    } 
		    if ok {
			    set timeLastChange=$piece($get(^SpeedI.DeltaP(cubeepis,epis)),r,2)
			    if timeLastChange'="" if ..IsChangeEpisode(epis,maxtime,timeLastChange,epis) { TROLLBACK  set isquit=1 quit }
			    kill ^SpeedI.DeltaP(cubeepis,epis)
			    
			    set timeLastChange=$piece($get(^SpeedI.DeltaP(cubeepisExt,epis)),r,2)
			    if timeLastChange'="" if ..IsChangeEpisode(epis,maxtime,timeLastChange,epis) { TROLLBACK  set isquit=1 quit }
		    } 
		    else  {
			    TROLLBACK
			    set iserrors=1
			    do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubeepisBI)_", episode="_$get(epis))
			    set isquit=1
			    quit
		    }
	        
	        if isquit=1 quit
	        /*
	        // EPVisitTestSetQueue 
	        set id=epis_"||"
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestsetqueue,id),1,vals) if (id="")||($piece(id,"||",1)'=epis)||(isquit=1) quit
		        set timeLastChange=$piece(vals,r,2)
	            if timeLastChange if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
		        set typechange=$piece(vals,r,1)
		        set ok=1
		        if typechange=1 {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetqueueBI,id)
		        } 
		        elseif typechange=0 {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetqueueBI,id)
			    }    
		        if ok {
			        set timeLastChange=$piece($get(^SpeedI.DeltaP(cubetestsetqueue,id)),r,2)
	                if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
			        kill ^SpeedI.DeltaP(cubetestsetqueue,id)
		        }
		        else  {
			        TROLLBACK
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetqueueBI)_", id="_$get(id))
			        set isquit=1
			        quit
		        }
            }
            
	        if isquit=1 quit
	        */
	        
	        // EPVisitTestSet удаление
	        set id=epis_"||"
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestset,id),1,vals) if (id="")||($piece(id,"||",1)'=epis)||(isquit=1) quit
		        set timeLastChange=$piece(vals,r,2)
	            if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
		        set typechange=$piece(vals,r,1)
		        if typechange'=0 continue
		        set ok=0
		        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetBI,id)
		        if ok {
			        set timeLastChange=$piece($get(^SpeedI.DeltaP(cubetestset,id)),r,2)
			        if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
			        kill ^SpeedI.DeltaP(cubetestset,id)
		        }
		        else  {
			        TROLLBACK
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Delete cube "_$get(cubetestsetBI)_", id="_$get(id))
			        set isquit=1
			        quit
		        }
            }
	        
	        if isquit=1 quit
	        
	        // EPVisitTestSet (пересчет куба для всех наборов тестов в данном эпизоде
	        set ts=""
	        for {
		        set ts=$order(^TEPI(epis,1,ts)) if (ts="")||(isquit=1) quit
		        set tscnt=""
		        for {
			        set tscnt=$order(^TEPI(epis,1,ts,tscnt)) if (tscnt="")||(isquit=1) quit
			        set id=epis_"||"_ts_"||"_tscnt
			        set vals=$get(^SpeedI.DeltaP(cubetestset,id))
			        if vals'="" {
				        set timeLastChange=$piece(vals,r,2)
	                    if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
			        }
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetBI,id)
			        
			        if ok {
				        // удаление ^SpeedI.DeltaP(cubetestset,id)
				        set vals=$get(^SpeedI.DeltaP(cubetestset,id))
			            if vals'="" {
				           set timeLastChange=$piece(vals,r,2)
	                       if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
			            }
				        kill ^SpeedI.DeltaP(cubetestset,id) 
			        }
		            else  {
			            TROLLBACK
			            set iserrors=1
			            do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetBI)_", id="_$get(id))
			            set isquit=1
			            quit
		            }
		        }
	        }
	        
	        if isquit=1 quit

	        // EPVisitTestSetData 
	        set id=epis_"||"
	        for {
		        set id=$order(^SpeedI.DeltaP(cubetestsetdata,id),1,vals) if (id="")||($piece(id,"||",1)'=epis)||(isquit=1) quit
		        set timeLastChange=$piece(vals,r,2)
	            if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
		        set typechange=$piece(vals,r,1)
		        set ok=1
		        if typechange=1 {
			        set ok=##class(%DeepSee.Utils).%ProcessFact(cubetestsetdataBI,id) 
			        do ##class(TCLEx.BI.Object.Event).LogEvent("RebuildCubes","CommitEpisode2","Id "_id,"",epis,id)  
		        } 
		        elseif typechange=0 {
			        set ok=##class(%DeepSee.Utils).%DeleteFact(cubetestsetdataBI,id)
			    }    
		        if ok {
			        set timeLastChange=$piece($get(^SpeedI.DeltaP(cubetestsetdata,id)),r,2)
	                if ..IsChangeEpisode(epis,maxtime,timeLastChange,id) { TROLLBACK  set isquit=1 quit }
			        kill ^SpeedI.DeltaP(cubetestsetdata,id)
		        }
		        else  {
			        TROLLBACK
			        set iserrors=1
			        do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:Update cube "_$get(cubetestsetdataBI)_", id="_$get(id))
			        set isquit=1
			        quit
		        }
            }

            if isquit=1 quit

            //удаление ^SpeedI.DeltaP(cubeepisExt,epis)
            set timeLastChange=$piece($get(^SpeedI.DeltaP(cubeepisExt,epis)),r,2)
			if timeLastChange'="" if ..IsChangeEpisode(epis,maxtime,timeLastChange,epis) { TROLLBACK  set isquit=1 quit }
			kill ^SpeedI.DeltaP(cubeepisExt,epis)

            if isquit=1 quit

            if isquit=0 {
	            // проверка последней даты изменений по всем кубам по эпизоду
	            set timeLastChange=..GetMaxDateChange(epis)   
	            if (timeLastChange'="")&&(..IsChangeEpisode(epis,maxtime,timeLastChange,epis)) { 
	                TROLLBACK  
	                set isquit=1
	                set isquit=1 s ^test("trb",epis)=timeLastChange_"*"_maxtime  
	                quit 
	            }  
	            TCOMMIT
	            do ##class(TCLEx.BI.Object.Event).LogEvent("RebuildCubes","CommitEpisode","Эпизод "_epis,"",epis,epis)
            }
            
	      } catch(e) {
		      TROLLBACK
		      set iserrors=1
		      set ok1=e.AsStatus()
		      do ##class(TCLEx.Function.General).WriteError($zerror,"TCLEx.BI.BuildIndices.RebuildCubes: episode="_$get(epis)_")")
	      }  
		    
        }
	} catch(e) { 
	    set ok1=e.AsStatus()
	    do ##class(TCLEx.Function.General).WriteError($zerror,"TCLEx.BI.BuildIndices.RebuildCubes") 
	}
	if (iserrors=1)&&(ok1=1) {
		set ok1=$$$ERROR($$$GeneralError,"Били ошибки при пересчете кубов. См. ^ERRORS")
	}
	quit ok1
]]></Implementation>
</Method>

<Method name="IsChangeEpisode">
<Description>
Изменился ли эпизод с момента pDateOfChangeCurrent</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String="",pDateOfChangeCurrent:%String="",pDateOfChangeLast:%String="",pLocation:%String=""</FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	set returnValue=$select(pDateOfChangeLast>pDateOfChangeCurrent:1,1:0)
	if returnValue=1 {
		do ##class(TCLEx.BI.Object.Event).LogEvent("RebuildCubes","RollBackEpisode","Эпизод "_pEpisode_" изменился во время пересчета кубов (момент изменения="_$zdate($piece(pDateOfChangeLast,".",1),4)_" "_$ztime($piece(pDateOfChangeLast,".",2)),"",pEpisode,pLocation)
	}
	quit returnValue
]]></Implementation>
</Method>

<Method name="GetMaxDateChange">
<Description>
Максимальная (позднейшая) дата-время изменения кубов по заданному эпизоду</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set returnValue=""
	try {
		if pEpisode="" quit
		
		set cubeepis="lab.EPVisitNumber"
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		
		
		// ^SpeedI.DeltaP(cubeepis)
		set horolog=$piece($get(^SpeedI.DeltaP(cubeepis,pEpisode)),$char(0),2)
		if +horolog>+returnValue set returnValue=horolog
        
        for cube=cubetestset,cubetestsetdata {  //,cubetestsetqueue {
	        set id=pEpisode_"||"
            for {
	           set id=$order(^SpeedI.DeltaP(cube,id),1,rec) if (id="")||($piece(id,"||",1)'=pEpisode) quit
	           set horolog=$piece(rec,$char(0),2)
	           if +horolog>+returnValue set returnValue=horolog
            }
        }
        // ^SpeedI.DeltaP("TCLEx.Data.EPVisitNumberExt")
        set class="TCLEx.Data.EPVisitNumberExt"
        set rec=$get(^SpeedI.DeltaP(class,pEpisode))
        set horolog=$piece(rec,$char(0),2)
        if +horolog>+returnValue set returnValue=horolog

	} catch(e) { 
	    set returnValue=""
	    do ##class(TCLEx.Function.General).WriteError($ze,$CLASSNAME()_":GetMaxDateChange("_$get(pEpisode)_")") 
	    }
	quit returnValue
]]></Implementation>
</Method>

<Method name="UpdateCubes3">
<Description>
для тестовых целей</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		set cubeepis="lab.EPVisitNumber"
		set cubeepisBI=$piece(cubeepis,".",2) //"TCBI.Cubes.EPVisitNumber"
		
		set cubetestset="lab.EPVisitTestSet"
		set cubetestsetBI=$piece(cubetestset,".",2) //"TCBI.Cubes.EPVisitTestSet"
		
		set cubetestsetdata="lab.EPVisitTestSetData"
		set cubetestsetdataBI=$piece(cubetestsetdata,".",2) //"TCBI.Cubes.EPVisitTestSetData"
		
		set cubetestsetqueue="lab.EPVisitTestSetQueue"
		set cubetestsetqueueBI=$piece(cubetestsetqueue,".",2) //"TCBI.Cubes.EPVisitTestSetQueue"
		
		// создаем буфер эпизодов, по которым будем пересчитывать все кубы
		//(TCBI.Cubes.EPVisitNumber,TCBI.Cubes.EPVisitTestSet,TCBI.Cubes.EPVisitTestSetQueue,TCBI.Cubes.EPVisitTestSetData)
		kill ^||bufRecountEpis
		// идем по ^TEPI (последние 500 эпизодов)
		set epis="",count=0
        for {
	        set epis=$order(^TEPI(epis),-1) if epis=""||(count>500) quit
	        set ^||bufRecountEpis(epis)=""
	        set count=count+1
        }
        // Чистим кубы
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubeepisBI))
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubetestsetBI))
        $$$ThrowOnError(##class(%DeepSee.Utils).%KillCube(cubetestsetdataBI))
        
        // Пересчитываем кубы
        set ok=..RebuildCubes($na(^||bufRecountEpis))
        if 'ok {
			do ##class(TCLEx.Function.General).WriteError($system.Status.GetErrorText(ok),"TCLEx.BI.BuildIndices:RebuildCubes")
		}
    } catch(exception) {
	       set ok=exception.AsStatus()
    }   
  quit ok
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// только для тех наборов тестов, для которых цена ещене финальная

]]></Content>
</UDLText>

<Method name="CreateEPVisitTestSetExt">
<Description>
Заполнение класса TCLEx.Data.EPVisitNumberExt - не в первый раз 
Пока только про цену все придумано
pFlagRecalcFinalPrice - флаг : если=1, то пересчитывать Все цены (любой flagFinalPrice)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String,pFlagRecalcFinalPrice:%Boolean=0,pDateStartBirlab:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=1
	set pEpisode=$get(pEpisode)
	   
	try {
		if pEpisode="" {
			set ok =$$$ERROR($$$GeneralError,"Не указан номер эпизода")
			quit
		}
		set epis=pEpisode
		// эпизод уже закрыт целиком для пересчета цены
	    if (pFlagRecalcFinalPrice=0)&&($lg($get(^TEPIext(epis)),1)=1) quit
	    
	    // дата, когда был запущен Birlab
	    if pDateStartBirlab="" {
		    set pDateStartBirlab=##class(BiRLab.Function.Report).GetDateStartUseBirlab() 
	    }
	    
	    kill supersetPrice // локальный массив для супенаборов
	    
	    // открываем или создаем объект TCLEx.Data.EPVisitNumberExt
	    if ##class(TCLEx.Data.EPVisitNumberExt).%ExistsId(epis) {
	          set objepis=##class(TCLEx.Data.EPVisitNumberExt).%OpenId(epis)
        } else {
	          set objepis=##class(TCLEx.Data.EPVisitNumberExt).%New()
	          set objepis.Episode=epis
              set ok1=objepis.%Save()
              if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        }
	    
	    // удаление удаленных EPVisitTestSet
	    set ts=""
	    for {
	        set ts=$order(^TEPIext(epis,1,ts)) if ts="" quit
	        set tscnt=""
	        for {
		        set tscnt=$o(^TEPIext(epis,1,ts,tscnt)) if tscnt="" quit
		        if '$data(^TEPI(epis,1,ts,tscnt)) {
			        set rowid=epis_"||"_ts_"||"_tscnt
                    set ok1=##class(TCLEx.Data.EPVisitTestSetExt).%DeleteId(rowid)
                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		        }
	        }
	    }
	    	    
	    set rec=$get(^TEPI(epis))
	
		set hospitalcode=$piece(rec,"\",20)
		set dateOfEntry=$piece(rec,"\",8)
		        
        // код плательщика на уровне эпизода
        set flagGetPayerFromTestSet=1 // флаг о том, что надо смотреть код плательщика на уровне наборов тестов, если дата авторизации меньше даты начала использования Биралаба
	    set payment="" 
        set ok1=##class(TCLEx.Function.Episode2).GetPayer0(epis,.hospitalcode,.payment,.flagGetPayerFromTestSet)
        if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        
        set paymentCategory=##class(BiRLab.Function.InvoiceNew).GetPaymentCategory(payment) // сейчас все равно он всегда =1
        
 	    set hospitalPayerCategoryVersion="",pricelistversion=""
        
        set citoepis=$piece(rec,"\",15) // cito нужно только для расчета цены по встроенному в трек биллингу, а это было только в Бионе - поэтому cito берем только на уровне эпизода

	    set ts=""
	    set flagFinalEpis=1  // флаг о том, что для всех наборов тестов эпизоде цена уже берется из BiRLab.Data.InvoiceEpisodeItem или набор тестов отменен (в этих двух случаях этот флаг=1)
	    for {
	        set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
	        set tscnt=""
	        for {
		        set tscnt=$o(^TEPI(epis,1,ts,tscnt),1,rects) if tscnt="" quit
		        set status=$piece(rects,"\",31)
		        set reason=$piece(rects,"\",52) 
		        if (status'="A")&&(reason="") {
			        set flagFinalEpis=0
			        // если раньше была причина отмены или авторизация, то надо почистить доп данные
			        if $data(^TEPIext(epis,1,ts,tscnt)) {
				        set recext=^TEPIext(epis,1,ts,tscnt)
				        set price=+$lg(recext,1)
				        set flagFinalPrice=$lg(recext,2)
				        set flagIsService=$lg(recext,4)
				        if (price'=0)||(flagFinalPrice=1)||(flagIsService=1) {
					        set rowid=epis_"||"_ts_"||"_tscnt
				            set obj=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(rowid)
                            if $IsObject(obj) {
	                          set obj.Price=0
                              set obj.FlagFinalPrice=0
                              set obj.FlagIsService=0
                              do obj.%SetModified(1)
                              set ok1=obj.%Save()
                              if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1) 
                            }
				        }
			        }
			        continue
		        } 
		        
		        // Если не надо пересчитывать финальную цену, то не пересчитываем
		        if (pFlagRecalcFinalPrice=0)&&($lg($get(^TEPIext(epis,1,ts,tscnt)),2)=1) continue
		 		 
		        set authdate=$Piece(rects,"\",4)
		        Set superset=$p(rects,"\",29)
		        set dateOfreason=$piece(rects,"\",54)
	        
		        set citots=$Piece(rects,"\",10)
		        
		        set flagIsService=1 //флаг, что данная строка будет считаться как одна услуга (для супернабора на ней же лежит цена за супернабор )
		        // если набор тестов отменен по причине,для которой выставлен флаг "Все равно оплачивать" в данном контексте это все равно, что набор тесов не отменен
		        set flagCancel=0  // флаг, что данная строка считает отмененной совсем (услугой не является)
		        if (dateOfreason'="")&&(reason'="") {
			        if $piece($get(^TTAB("CTR",reason)),"\",3)'="Y" set flagCancel=1  
		        }
		        
  		        if (flagGetPayerFromTestSet=1)&&(((pDateStartBirlab'="")&&(authdate<pDateStartBirlab))) {
	                ; плательщик (на уровне набора тестов)
                    set paymentts=$p(rects,"\",23) 		;VISTS_PaymentCode_DR
                    if paymentts'="" set payment=paymentts
                }
		         
		        set price=""
		        set flagFinalPrice=0
		        
		        // если причина невыполения проставлена, то пишем цену 0 и проставляем флаг окончательности цены (если это не супернабор)
		        // в супернаборе часть наборов тестов может быть отменена, а часть сделана
		        if (flagCancel=1)&&(superset="") {    
		            set price=0  // в дальнейшем коде цена не пересчитывается в этом случае
		            set flagFinalPrice=1
		            set flagIsService=0
		        }
		        
		        // Если это неоплачиваемая услуга (VISTS_SupressBilling="Y"), то 
		        // для обычных наборов тестов : считаем кол-во услуг 1 и цена 0 и проставляем флаг финальной цены 
		        // для супернабора - если для "главного" набора тестов ISTS_SupressBilling="Y", то весь супернабор рассматривается как одна услуга с 0 ценой - например такой вариант жизни
		        set supressbilling=$piece(rects,"\",34)
		        
		        if (supressbilling="Y")&&(superset="") {  // неоплачиваемый набор тестов (но услуга считается услугой)
			        set price=0
			        set flagFinalPrice=1
			        set flagIsService=$select(authdate'="":1,1:0)
		        }
			       	        
		        set billingitem=ts
		        
                // обоработка супернабора
                if superset'="" {
	                Set billingitem=superset
	                set flagmaintestset=ts[superset // флаг, что это "главный" Набор тестов в супернаборе 
	                // если на какой-то набор тестов из супер набора уже записана цена за супернабор, то на другие наборы тестов записываем 0
	                If ($Data(supersetPrice(billingitem,tscnt)))||(flagmaintestset=0) {
		                set price=0
		                set flagFinalPrice=1  
		                set flagIsService=0
	                } else {
		                // если этот набор тестов отменен, то просто записываем в ^TEPIext цену 0 и флаг окончательности цены, но цену жля супернабора не записываем
		                set flagIsComplete=##class(TCLEx.Function.SuperSet).IsComplete(epis,superset) 
		                if (flagCancel=0)&&(flagIsComplete=1) {
			                set flagIsService=1
		                    set authdate=##class(TCLEx.Function.SuperSet).AuthorisationDate2(epis,superset)
		                    Set supersetPrice(billingitem,tscnt)="" 
		                    if supressbilling="Y" {
			                    set price=0
			                    set flagFinalPrice=1
		                    }
		                } else {
			                set price=0
			                set flagIsService=0
			                if flagIsComplete=1 set flagFinalPrice=1
		                }
	                }
                }
                set cito=$select(citots'="":citots,citoepis'="":citoepis,1:"")
                
	            // расчет цены по старому биллингу
                if ((pDateStartBirlab="")||(authdate<pDateStartBirlab)) {
	                //if '$data(^TEPIext(epis)) set $list(^TEPIext(epis),1)=1  // для этого эпизода не пересчитываем цены никогда (если в эпизоде хотя бы один набор тестов попал авторизован до появления Бирлаб, то считаем весь эпизод добирлабовским)
	                set flagFinalEpis=1
	                set flagFinalPrice=1
	                if price="" {
		                if (payment'="") 
		                {
			                Set price=$$GetBillingItemAmount^PRTCLNRUS05birlab(payment,epis,authdate,billingitem,cito,$name(^||invForGetPrice))
		                } else {
			                //set ok=$system.Status.AppendStatus(ok,$$$ERROR($$$GeneralError,"Не указан код плательщика для эпизода "_epis_" hospitacode="_$get(hospitalcode)))
			                //set ^test("fras","no_plat",epis,billingitem)=$get(hospitalcode)
			                set price=0
		                }
	                }
                }
                // расчет цены по новому биллингу
                else {
	                 if price="" {
		                    // смотрим цену окончательно закрепленную
		                    set ok1=##class(BiRLab.Function.InvoiceNew).GetFinalPrice(epis,billingitem,ts,tscnt,.cito,.flagFinalPrice,.price)
		                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		                    if (flagFinalPrice=0) {
			                    set ok1=##class(BiRLab.Function.InvoiceNew).GetPrice(payment, hospitalcode, paymentCategory, billingitem, dateOfEntry, cito, .pricelistversion, .hospitalPayerCategoryVersion,.price )
			                    if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
		                    }
	                 }
                }
                if ($data(supersetPrice(billingitem,tscnt)))&&(flagIsService=1) {
	                Set supersetPrice(billingitem,tscnt)=flagFinalPrice
                }
                
                // запись в TCLEx.Data.EPVisitTestSetExt
                //set ^TEPIext(epis,1,ts,tscnt)=$listbuild(price,flagFinalPrice)
                set rowid=epis_"||"_ts_"||"_tscnt
                set obj=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(rowid)
                if '$IsObject(obj) {
	                set obj=##class(TCLEx.Data.EPVisitTestSetExt).%New()
	                set obj.Episode=objepis
	                do obj.TestSetSetObjectId(ts)
	                set obj.TestSetCounter=tscnt
                }
                set obj.Price=price
                set obj.FlagFinalPrice=flagFinalPrice
                set obj.SuperSet=superset
                set obj.FlagIsService=flagIsService
                do obj.%SetModified(1)
                set ok1=obj.%Save()
                if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
                
                if (flagFinalEpis=1)&&(flagFinalPrice=0) {
	                set flagFinalEpis=0
                } 
	        }
	        
        }
        
	    // запись в TCLEx.Data.EPVisitNumberExt and ^EPVisitNumber
        //set ^TEPIext(epis)=$listbuild(hospital,payment,flagFinalPrice)
        set recext=^TEPIext(epis)
        set hospitalold=$listget(recext,1),payerold=$listget(recext,2),flagFinalEpisOld=$listget(recext,3)
        if (hospitalcode'=hospitalold)||(payment'=payerold)||(flagFinalEpis'=flagFinalEpisOld) {
                set objepis.Payer=payment
                set objepis.FlagFinalPrice=flagFinalEpis
                do objepis.HospitalSetObjectId(hospitalcode)
                do objepis.%SetModified(1)
                set ok1=objepis.%Save()
                if 'ok1 set ok=$system.Status.AppendStatus(ok,ok1)
        }
        
        kill supersetPrice
        
	} catch(e) {
		set ok1=e.AsStatus()
		set ok=$system.Status.AppendStatus(ok,ok1)
	}
	if 'ok do ##class(TCLEx.Function.General).WriteError($ze,"TCLEx.BI.BuildIndices:CreateEPVisitTestSetExt:episode="_$get(epis))
	quit ok
]]></Implementation>
</Method>

<Method name="BIClassChange">
<Description>
Установить флаг изменения для пересчета данных в TCLEx.Data.EPVisitNumberExt (дополнительные данные по эпизоду)
Несоответсвующее название осталось исторически 
pClass - deprecated
pId - номер эпизода
pFlagDelete - deprecated
pInfo - флаг пересчета окончательной цены</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pClass:%String="",pId:%String="",pFlagDelete:%Boolean="N",pInfo:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		/*
	    if (pClass'="")&&(pId'="") {
		    if pFlagDelete="Y" set ^SpeedI.DeltaP(pClass,pId)=0
	        else  set ^SpeedI.DeltaP(pClass,pId)=1
	    }
	    // дополнительная информация (например при удалении BiRLab.Data.InvoiceEpisodeItem в ней номер эпизода)
	    if pInfo'="" {
		    set ^SpeedI.DeltaP(pClass,pId,"info")=pInfo
	    }
	    */
	    set flagCalcFinalPrice=+pInfo // флаг обязательности пересчета цены (даже если установлен флаг финальной цены (цена взята из BiRLab.Data.InvoiceEpisodeItem))
	    set ok=##class(TCLEx.Task.ExtraCalcQueueManager).InsertInQueue(pId,flagCalcFinalPrice)
	    
	} catch(e) { set ok=e.AsStatus() }
	
	quit ok
]]></Implementation>
</Method>

<Method name="ExtraDataChange">
<Description>
Установить флаг изменения для пересчета данных в TCLEx.Data.EPVisitNumberExt (дополнительные данные по эпизоду)
pFlagCalcFinalPrice - флаг обязательности пересчета цены (даже если установлен флаг финальной цены (цена взята из BiRLab.Data.InvoiceEpisodeItem))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pEpisode:%String="",pFlagCalcFinalPrice:%Boolean="N"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
	    set ok=##class(TCLEx.Task.ExtraCalcQueueManager).InsertInQueue(pEpisode,pFlagCalcFinalPrice)
	    
	} catch(e) { set ok=e.AsStatus() }
	
	quit ok
]]></Implementation>
</Method>

<Method name="InitialBuild">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ok=$$$OK
  try {
	// a complete rebuild of all cubes
	
	kill ^SpeedI.DeltaP
	
	set ts1=+$h*100000+$p($h,",",2)
	s ^test("buildcube","start")=$h
	
	do ##class(%DeepSee.Utils).%KillCube("EPVisitNumber")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSet")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSetData")
	
	//do CreateIndex^PRTCLNRUS05birlab($name(^invForGetPrice))
	//set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExtFirst()
	b  //
	//do ..BindTestSetSpecimen()
	//d ##class(%DeepSee.Utils).%BuildCube("BBPPackDetails",0)
	//d ##class(%DeepSee.Utils).%BuildCube("BBPPackTransactions",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitNumber",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSet",0)
	d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetData",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetDataAntib",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetQueue",0)
	//d ##class(%DeepSee.Utils).%BuildCube("EPVisitTestSetSnomedRes",0)
	set ts2=+$h*100000+$p($h,",",2)
	set ras=ts2-ts1
	set ^test("BuildCubes")=ras_" сек "_(ras\3600)_" ч"
	w !,ras_" сек "_(ras\3600)_" ч"
  } catch(e) { set ok=e.AsStatus() }
  q ok
]]></Implementation>
</Method>

<Method name="InitialCaclPrice">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set ok=$$$OK
  try {
	
	kill ^SpeedI.DeltaPext
	
	set ts1=+$h*100000+$p($h,",",2)
	s ^test("calcprice","start")=$h
	//do CreateIndex^PRTCLNRUS05birlab($name(^invForGetPrice))
	set ok=##class(TCLEx.BI.BuildIndices).CreateEPVisitTestSetExtFirst()
	set ts2=+$h*100000+$p($h,",",2)
	set ras=ts2-ts1
	set ^test("calcprice","stop")=$h_" ras="_ras_" сек "_(ras\3600)_" ч"
	w !,ras_" сек "_(ras\3600)_" ч"
  } catch(e) { set ok=e.AsStatus() }
  q ok
]]></Implementation>
</Method>

<Method name="CreateEPVisitTestSetExtFirst">
<Description>
Заполнение класса TCLEx.Data.EPVisitNumberExt - в первый раз (перед первым строительством кубов по уже имеющимся данным)
Пока только про цену все придумано</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=1
	try {
		// создание индекса для быстрого расчета цены по сарому биллингу
	    do CreateIndex^PRTCLNRUS05birlab($name(^||invForGetPrice))
	
	    kill ^TEPIext,^TEPIextI
	
	    set dateStartBirlab=##class(BiRLab.Function.Report).GetDateStartUseBirlab()
	    
	    set epis="" 
	    for {
		    set epis=$order(^TEPI(epis)) if epis="" quit
		    set ok1=..CreateEPVisitTestSetExt(epis,1,dateStartBirlab)
		    if 'ok1 {
			    write !,"episode="_epis
			    do $system.Status.DisplayError(ok1)
			    //set ok=$system.Status.AppendStatus(ok,ok1)
			    //quit
		    }
        }
        do ..SetFlagFinalPrice() // Для некоторых эпизодов насильственно в первый раз поставить флаг окончательности цены
	} catch(e) {
		
	}
	quit ok
]]></Implementation>
</Method>

<Method name="SetFlagFinalPrice">
<Description>
Для некоторых эпизодов насильственно в первый раз поставить флаг окончательности цены</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set datelimit=$extract($zd(+$h,8),1,6)-7
	set ok=1
	try {
		set counter=0
		set hospital=""
		for {
			set hospital=$order(^TEPIextI("FlagFinalPriceHospital",0,hospital)) if hospital="" quit
			set epis=""
		    for {
			   set epis=$order(^TEPIextI("FlagFinalPriceHospital",0,hospital,epis)) if epis="" quit
			   set dateOfEntry=$extract($zd($piece(^TEPI(epis),"\",8),8),1,6)
			   if dateOfEntry>datelimit continue
			   set objepis=##class(TCLEx.Data.EPVisitNumberExt).%OpenId(epis)
			   set objepis.FlagFinalPrice=1
			   do objepis.%SetModified(1)
			   set ok1=objepis.%Save()
			   if 'ok1  do $system.Status.DisplayError(ok1)
			   set counter=counter+1
			   set ts=""
			   for {
				   set ts=$order(^TEPIext(epis,1,ts)) if ts="" quit
				   set tscnt=""
				   for {
					   set tscnt=$order(^TEPIext(epis,1,ts,tscnt),1,rects) if tscnt="" quit
					   if $listget(rects,2)=1 continue
					   set objts=##class(TCLEx.Data.EPVisitTestSetExt).%OpenId(epis_"||"_ts_"||"_tscnt)
					   set objts.FlagFinalPrice=1
					   do objts.%SetModified(1)
					   set ok1=objts.%Save()
					   if 'ok1  do $system.Status.DisplayError(ok1)
				   }
			   }
		    }
		}
		write !,"Для эпизодов полугодовой давности насильственно проставлен флаг финальной цены: "_counter_" эпизодов",!
	} catch(e) {
		do $system.Status.DisplayError(e.AsStatus())
	}
	quit ok
]]></Implementation>
</Method>

<Method name="ForTest">
<ClassMethod>1</ClassMethod>
<Implementation><![CDATA[
	do ##class(TCLEx.Task.ExtraCalcQueueManager).DoTask()
	set ok=..UpdateCubes()
]]></Implementation>
</Method>

<Method name="CalcForTest">
<Description>
метод не доделан</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pCouter:%Integer=1000</FormalSpec>
<Implementation><![CDATA[
	//do ##class(%DeepSee.Utils).%KillCube("EPVisitNumber")
	//do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSet")
	//do ##class(%DeepSee.Utils).%KillCube("EPVisitRestSetData")
	set count=0
	set epis=""
        for {
	        set epis=$order(^TEPI(epis)) if epis="" quit
	        set count=count+1
	        if count>pCouter quit
	        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitNumber",epis)
		    if 'ok {
			    do $system.Status.DisplayError(ok)
		    } 
	        
	        // EPVisitTestSet (пересчет куба для всех наборов тестов в данном эпизоде
	        set ts=""
	        for {
		        set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
		        set tscnt=""
		        for {
			        set tscnt=$order(^TEPI(epis,1,ts,tscnt)) if tscnt="" quit
			        set id=epis_"||"_ts_"||"_tscnt
			        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitTestSet",id)
			        if 'ok {
				        do $system.Status.DisplayError(ok)
			        }
			        set test=""
			        for {
				        set test=$order(^TEPI(epis,1,ts,tscnt,"DATA",test)) if test="" quit
				        set id=epis_"||"_ts_"||"_tscnt_"||"_test
				        set ok=##class(%DeepSee.Utils).%ProcessFact("EPVisitTestSetData",id)
			            if 'ok {
				           do $system.Status.DisplayError(ok)
			            }
			        }
		        }
	        }

        }
]]></Implementation>
</Method>

<Method name="BindTestSetSpecimen">
<Description>
Проверяем привязку образца к набору тестов, если ее нет, то моделируем открытие окна Образцы из справочника наборов тестов (в этот момент связка создается, если образеу задан для тестов)</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set ok=$$$OK
	try {
		set pGlb=$name(^log("addSpecimenToTestSet"))
		set ts=""
        for {
	       set ts=$o(^TTAB("TS",ts),1,rec) if ts="" quit
	       if '$data(^TTAB("TS",ts,0)) continue  // если нет шаблона
	       if $piece(rec,"\",12)'="Y" continue
	       if $piece(rec,"\",31)="" continue
	       set specimen=##class(TCLEx.Function.TestSet).DefaultSpecimen(ts)
	       if specimen="" {
		       if $$open^LVBCTTSY(ts,"","","","","","","","","")
			   if $$close^LVBCTTSY()
			   set specimen=##class(TCLEx.Function.TestSet).DefaultSpecimen(ts)
			   if specimen'="" {
				   set @pGlb@($i(@pGlb))="У набора тестов "_ts_" не был указан материал образца. Теперь привязан код материала образца "_specimen
				   kill ^log("nospecimen",ts)
			   } else {
				   set ^log("nospecimen",ts)=""
			   }
	       }
		}
	} catch(e) {
		set ok=e.AsStatus()
	}
	quit ok
]]></Implementation>
</Method>

<Method name="BuildCubesForTesting">
<Description>
Построение кубов с данными только за январь 2014</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDateFrom:%String="",pDateTo:%String=""</FormalSpec>
<Implementation><![CDATA[
	if pDateFrom="" set pDateFrom=$zdh("01/01/2014",4)
	if pDateTo="" set pDateTo=$zdh("31/01/2014",4)
	set horolog=$p($h,",",1)_"."_($p($h,",",2)-3600)
	
	do ##class(%DeepSee.Utils).%KillCube("EPVisitNumber")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSet")
	do ##class(%DeepSee.Utils).%KillCube("EPVisitTestSetData")

	
	kill ^SpeedI.DeltaP
	// По дате авторизации
	set date=pDateFrom-1 
	for {
		set date=$o(^TEPIi("AUTHORISED",date)) q:date=""  q:date>pDateTo
		s epis="" 
		for {
			s epis=$o(^TEPIi("AUTHORISED",date,epis)) q:epis=""  
			set ^SpeedI.DeltaP("lab.EPVisitNumber",epis)="1"_$char(0)_horolog
		}
	}
	// по дате DateOfEntry
	set date=pDateFrom-1
    for {
	   set date=$order(^TDAY(4,date)) quit:date=""  quit:date>pDateTo  
	   set epis="" 
	   for {
		 set epis=$order(^TDAY(4,date,0,epis)) if epis="" quit
         set ^SpeedI.DeltaP("lab.EPVisitNumber",epis)="1"_$char(0)_horolog
	   }
    }
    set epis=""
    for {
	    set epis=$order(^SpeedI.DeltaP("lab.EPVisitNumber",epis)) if epis="" quit
	    set ts=""
	    for {
		    set ts=$order(^TEPI(epis,1,ts)) if ts="" quit
		    set tscnt=""
		    for {
			    set tscnt=$o(^TEPI(epis,1,ts,tscnt)) if tscnt="" q
			    set test=""
			    for {
				    set test=$o(^TEPI(epis,1,ts,tscnt,"DATA",test)) if test="" q
				    set ^SpeedI.DeltaP("lab.EPVisitTestSetData",epis_"||"_ts_"||"_tscnt_"||"_test)="1"_$char(0)_horolog
			    }
		    }
	    }
    }
    
    do ..UpdateCubes()
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// end class

]]></Content>
</UDLText>
</Class>
</Export>
