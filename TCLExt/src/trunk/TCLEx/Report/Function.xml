<?xml version="1.0" encoding="UTF-8"?>
<Export generator="Cache" version="24">
<Class name="TCLEx.Report.Function">
<Super>%RegisteredObject</Super>
<TimeCreated>62441,61023.991741</TimeCreated>

<Method name="TestAccessUserToReport0">
<Description>
output: 1/0 - есть / нет доступа
По группам отчетов, привязанных к пользователю (в Trak это используется для выбора адресата печати, что нехорошо)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUser:%String,pReportKey:%String,&pMessageError:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	 set pMessageError=""
	 if $get(pReportKey)="" quit 0
	 set recReport=$get(^TTAB("REPORT-GENERIC",pReportKey))
     set reportGroup=$piece(recReport,"\",4) 
     if reportGroup="" set pMessageError="Не удалось идентифицировать группу для отчета" quit 0
          
     set userobj = ##class(User.SSUser).%OpenId(pUser)
     if '$IsObject(userobj) set pMessageError="Не удалось идентифицировать пользователя" quit 0
     set grp="",ok=0
     for {
	     set userReportGroupobj=userobj.ChildSSUserReportGroup.GetNext(.grp) if grp="" quit 
	     set userReportGroup =  userReportGroupobj.SURPRepGroupDR
	     set userReportGroupCode="" if $IsObject(userReportGroup) set userReportGroupCode=userReportGroup.CTPGCode
	     if reportGroup=userReportGroupCode set ok=1 quit 
     }
     if ok=0 set pMessageError="Для пользователя "_pUser_" данный отчет не доступен." quit 0
     quit 1
]]></Implementation>
</Method>

<Method name="TestAccessUserToReport00">
<Description>
output: 1/0 - есть / нет доступа
По внешней привязке группа пользователей - отчет </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUser:%String,pReportKey:%String,&pMessageError:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	 //s ^test(1)=$g(pUser)_"*"_$g(pReportKey)
	 set pMessageError=""
	 if $get(pReportKey)="" set pMessageError="Не удалось идентифицировать отчет" quit 0
         
     set userobj = ##class(User.SSUser).%OpenId(pUser)
     if '$IsObject(userobj) set pMessageError="Не удалось идентифицировать пользователя" quit 0
     set usergroup=userobj.SSUSRGroup
     set ok=+##class(TCLEx.Data.BindUserReport).GetFlagUseReportByUserGroup(usergroup.%Id(),pReportKey) 
     if ok=0 set pMessageError="Для пользователя "_pUser_" данный отчет не доступен." quit 0
     quit 1
]]></Implementation>
</Method>

<Method name="TestAccessUserToReport">
<Description>
output: 1/0 - есть / нет доступа</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[pUser:%String,&pMessageError:%String]]></FormalSpec>
<ReturnType>%Boolean</ReturnType>
<Implementation><![CDATA[
	 set pMessageError=""
	 set reportKey=$G(^TMP("REPORTSPB",$j))
	 if reportKey="" set pMessageError="Не удалось идентифицировать отчет" quit 0
	 quit ..TestAccessUserToReport0(pUser, reportKey, .pMessageError)
]]></Implementation>
</Method>

<Method name="TestAccessUserToReportVB">
<Description>
output: 1                - есть доступ 
        0_$char(1)_error - нет доступа</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pUser:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if $get(pUser)="" quit "0"_$char(1)_"Не удалось идентифицировать пользователя"
	
	set reportKey=$G(^TMP("REPORTSPB",$j))
	if reportKey="" quit "0"_$char(1)_"Не удалось идентифицировать отчет"
	
	set message=""
	if ..TestAccessUserToReport00(pUser,reportKey,.message)=0 {
		quit "0"_$char(1)_$get(message)
	} 
	else 
	{
		quit 1
	}
]]></Implementation>
</Method>

<Method name="Age">
<Description>
до месяца - в днях ("1 д.", "2 дн.", "12 дн.", "21 дн." и "1 d.", "5 d.")
до года - в полных месяцах ("1 мес.", "10 мес." и "1 m.")
от года до трех лет - в годах и полных месяцах ("1 год 2 мес.", "2 года 7 мес." и "1 y. 2 m.", "2 y. 7 m.")
от трех лет - в полных годах ("4 лет", "21 лет", "35 лет" и "4 y.o.", "35 y.o.")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pDOB:%Date,pDateOfCollection:%Date,pLanguage:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Set pLanguage=$Get(pLanguage) 
	Set result=$Select(pLanguage=2:"Unknown",1:"Неизвестен")        
	If pDOB'="" {
		Set age=..CalAge(pDOB,pDateOfCollection) ;вычисление возраста пациента  "год|месяц|день" на момент "даты забора" биоматериала
		Set ageyear=$Piece(age,"|",1)
		Set agemonth=$Piece(age,"|",2)
		Set ageday=$Piece(age,"|",3)
		//от 1 года до 3 лет ... лет ... мес
		If (ageyear>0)&&(ageyear<3) {
		     Set result=ageyear_" "_$Select(pLanguage=2:"y.",1:$select(ageyear=1:"год",1:"года"))
		     if agemonth>0 set result=result_" "_agemonth_" "_$Select(pLanguage=2:"m.",1:"мес.")	
		} ElseIf (ageyear>0) {
			 set lastdig=ageyear#10,lastdig2=ageyear#100
			 Set result=ageyear_" "_$Select(pLanguage=2:"y.o.",1:$select((lastdig2>4)&&(lastdig2<21):"лет",lastdig=1:"год",(lastdig>1)&&(lastdig<5):"года",1:"лет"))
		} ElseIf (agemonth>0) {
			 Set result=agemonth_" "_$Select(pLanguage=2:"m.",1:"мес.")
		} ElseIf (ageday>0){
			 Set result=ageday_" "_$Select(pLanguage=2:"d.",1:"дн.")
		}			 
	}
	Quit result
]]></Implementation>
</Method>

<Method name="CalAge">
<Description>
Функция СП.Арма по вычислению возраста по дню рождения на заданную дату в формате "год|месяц|день"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>IBirth:%Date,IToday:%Date</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 ;hack of date of birth
 s IBirth=$g(IBirth) s:IBirth>2980000 IBirth="" s:IBirth<0 IBirth="" q:'$G(IBirth) ""
 s IToday=$g(IToday) s:IToday="" IToday=$h
 s XBirth=$ZD(IBirth)
 s XToday=$ZD(IToday)
 s AgeMth=XToday-XBirth
 s AgeDay=$p(XToday,"/",2)-$p(XBirth,"/",2)
 s CurrYear=$p(XToday,"/",3) s:CurrYear<100 CurrYear=CurrYear+1900
 s BirthYear=$p(XBirth,"/",3) s:BirthYear<100 BirthYear=BirthYear+1900
 s AgeYear=CurrYear-BirthYear
 i AgeDay<0 d
 . s AgeMth=AgeMth-1
 . s AgeDay=AgeDay+$p("31,31,28,31,30,31,30,31,31,30,31,30,31",",",+XToday)
 . q:XToday'=2
 . s:((CurrYear#4)=0)&(((CurrYear#100)'=0)!((CurrYear#400)=0)) AgeDay=AgeDay+1
 i AgeMth<0 s AgeMth=AgeMth+12,AgeYear=AgeYear-1
 q AgeYear_"|"_AgeMth_"|"_AgeDay
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// Расположение файла fop.xsl для zenreport 

]]></Content>
</UDLText>

<UDLText name="T">
<Content><![CDATA[
// Там же , где лежит fop.bat

]]></Content>
</UDLText>

<Method name="GetPathToXSL">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set returnValue=$get(^%SYS("zenreport","transformerpath"))
	set returnValue=$piece(returnValue,"\",1,$length(returnValue,"\")-1)
	set returnValue=returnValue_"\"_"fop.xsl"
	quit returnValue
]]></Implementation>
</Method>

<UDLText name="T">
<Content><![CDATA[
// CFSMPathToImagesServer

]]></Content>
</UDLText>

<Method name="ImagePath">
<Description>
Путь к каталогу с графическими файлами</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	//Quit "C:\InterSystems\Ensemble\CSP\bion\Report"
	set path=""
	&sql(select CFSM_PathToImagesServer into :path from SQLUSER.CF_SystemDefaults where CFSM_RowId='1')
	if SQLCODE'=0 {
		set path=""
	}
	set len=$length(path)
	if $tr($extract(path,len),"/","\")="\" set path=$extract(path,1,len-1)
	
	quit path
]]></Implementation>
</Method>
</Class>
</Export>
